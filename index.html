<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/ganru.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/ganru.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/ganru.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/ganru.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/ganru.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/ganru.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/ganru.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="学习一向都是孤独的，慢慢玩。">
<meta property="og:type" content="website">
<meta property="og:title" content="小黑屋">
<meta property="og:url" content="https://ganru.github.io/index.html">
<meta property="og:site_name" content="小黑屋">
<meta property="og:description" content="学习一向都是孤独的，慢慢玩。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="小黑屋">
<meta name="twitter:description" content="学习一向都是孤独的，慢慢玩。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/ganru.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ganru.github.io/"/>





  <title>小黑屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/ganru.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/ganru.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/ganru.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-essay">
          <a href="/ganru.github.io/categories/随笔" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            随笔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-write">
          <a href="/ganru.github.io/categories/写作" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            写作
          </a>
        </li>
      
        
        <li class="menu-item menu-item-read">
          <a href="/ganru.github.io/categories/阅读" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            阅读
          </a>
        </li>
      
        
        <li class="menu-item menu-item-study">
          <a href="/ganru.github.io/categories/学习" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            学习
          </a>
        </li>
      
        
        <li class="menu-item menu-item-code">
          <a href="/ganru.github.io/categories/编程" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            编程
          </a>
        </li>
      
        
        <li class="menu-item menu-item-py_code">
          <a href="/ganru.github.io/categories/Python笔记" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Python
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/10/24/数据可视化（第二部分）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/10/24/数据可视化（第二部分）/" itemprop="url">数据可视化（第二部分）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-24T16:51:08+08:00">
                2018-10-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<p>上一部分我们学了如何生成数据，这一次，我们学习如何下载数据。</p>
<ul>
<li>数据可视化有两种常见的存储格式：CSV 和 JSON 。</li>
<li>处理 CSV 数据，我们用 Python 自带的模块 csv 处理。</li>
<li>处理 JSON 数据，我们用 模块 json 处理。</li>
<li>这一环节，我们依然使用 matplotlib 库与 pygal 库进行数据可视化。</li>
</ul>
<h1 id="CSV-文件格式"><a href="#CSV-文件格式" class="headerlink" title="CSV 文件格式"></a>CSV 文件格式</h1><p>csv 文件称为 逗号分隔值文件。其形式如下：</p>
<p><code>2014-1-5,61,44,26,18,7,-1,56,30,9,30.34,30.27,30.15,,,,10,4,,0.00,0,,195</code></p>
<h2 id="分析-CSV-文件头"><a href="#分析-CSV-文件头" class="headerlink" title="分析 CSV 文件头"></a>分析 CSV 文件头</h2><p><strong>highs_lows.py</strong></p>
<hr>
<pre><code>import csv

filename = &apos;sitka_weather_07-2014.csv&apos;
with open(filename) as f:
    reader = csv.reader(f)
    header_row = next(reader)
    print(header_row)
</code></pre><ul>
<li>文件名记得打 <strong>后缀</strong>。</li>
<li>创建一个阅读器 (reader) 对象并将之与 csv 文件关联。</li>
<li>模块 csv 包含函数 next()，调用它并将阅读器对象传递给它时，它将返回文件中的下一行。这里我们只调用第一行（头行）</li>
</ul>
<h2 id="打印文件头及其位置"><a href="#打印文件头及其位置" class="headerlink" title="打印文件头及其位置"></a>打印文件头及其位置</h2><p>为让文件头数据更容易理解，将列表中的每个文件头及其位置打印出来：</p>
<pre><code>import csv

filename = &apos;sitka_weather_07-2014.csv&apos;
with open(filename) as f:
    reader = csv.reader(f)
    header_row = next(reader)

    for index, column_header in enumerate(header_row):
        print(index, column_header)
</code></pre><ul>
<li>enumerate() 是 python 的内置函数</li>
<li>enumerate 在字典上是枚举、列举的意思</li>
<li>对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate 将其组成一个索引序列，利用它可以同时获得索引和值</li>
<li>enumerate 多用于在 for 循环中得到计数</li>
</ul>
<p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/1.png"></p>
<p>利用 enumerate() 函数，可以看到，我们直观地展现出了 csv 文件的数据。</p>
<p>文件头 AKDT 表示阿拉斯加时间（Alaska Daylight Time），其位置表明每行的第一个值都是日期或时间。文件头 Max TemperatureF 指出每行的第二个值都是当天的最高华氏温度。后面的自行翻译。。。</p>
<h2 id="提取并读取数据"><a href="#提取并读取数据" class="headerlink" title="提取并读取数据"></a>提取并读取数据</h2><p>知道需要哪些列中的数据后，我们来读取一些数据。首先读取每天的最高气温：</p>
<pre><code>with open(filename) as f:
    reader = csv.reader(f)
    header_row = next(reader)

    highs = []
    for row in reader:
        # 将第一列的数据添加到列表 highs
        highs.append(row[1])

    print(highs)
</code></pre><p>我们可以看到：</p>
<p>[‘64’, ‘71’, ‘64’, ‘59’, ‘69’, ‘62’, ‘61’, ‘55’, ‘57’, ‘61’, ‘57’, ‘59’, ‘57’, ‘61’, ‘64’, ‘61’, ‘59’, ‘63’, ‘60’, ‘57’, ‘69’, ‘63’, ‘62’, ‘59’, ‘57’, ‘57’, ‘61’, ‘59’, ‘61’, ‘61’, ‘66’]</p>
<p>有点儿不太好看，我们用 int() 将它们转换为数字，这样 matplotlib 才好访问它们：</p>
<pre><code>highs = []
for row in reader:
    high = int(row[1])
    highs.append(high)

print(highs)
</code></pre><p>这时候：</p>
<p>[64, 71, 64, 59, 69, 62, 61, 55, 57, 61, 57, 59, 57, 61, 64, 61, 59, 63, 60, 57, 69, 63, 62, 59, 57, 57, 61, 59, 61, 61, 66]</p>
<p>接下来将此数据可视化。</p>
<h2 id="绘制气温图表"><a href="#绘制气温图表" class="headerlink" title="绘制气温图表"></a>绘制气温图表</h2><pre><code>from matplotlib import pyplot as plt

# 根据数据绘制图形
fig = plt.figure(dpi=128, figsize=(10, 6))
plt.plot(highs, c=&apos;red&apos;)

# 设置图形的格式
plt.title(&quot;Daily high temperatures, July 2014&quot;, fontsize=24)
plt.xlabel(&apos;&apos;, fontsize=16)
plt.ylabel(&quot;Temperature (F)&quot;, fontsize=16)

plt.show()
</code></pre><p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/2.jpg"></p>
<h2 id="模块-datetime"><a href="#模块-datetime" class="headerlink" title="模块 datetime"></a>模块 datetime</h2><p>画好大致的温度折线图，现在我们添加上日期。在此之前我们先了解下模块 datetime 的用法：</p>
<pre><code>&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; first_date = datetime.strptime(&apos;2014-7-1&apos;, &apos;%Y-%m-%d&apos;)
&gt;&gt;&gt; print(first_date)
2014-07-01 00:00:00
</code></pre><p>在 IDLE 中编写，我们直观地看下它的做法：</p>
<ul>
<li>在这段演示中方法 strptime() 接收两个实参：前者是需要导入的日期的字符串，后者告诉 Python 如何设置日期的格式。</li>
<li>‘%Y-‘ 让 Python 将字符串中第一个连字符 - 前面的部分视为四位的年份</li>
<li>‘%m-‘ 让 Python 将第二个连字符 - 前面的部分视为表示月份的数字</li>
<li>‘%d’ 让 Python 将字符串的最后一部分视为月份中的一天 (0~31)</li>
</ul>
<p>方法 strptime() 可接受各种实参，并根据它们来决定如何解读日期。具体看下表：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/3.jpg"></p>
<p>现在我们尝试提取日期并导入绘制图中：</p>
<pre><code>import csv
from datetime import datetime

from matplotlib import pyplot as plt

with open(filename) as f:
    --snip--

    highs = []
    dates = []
    for row in reader:
        current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)
        dates.append(current_date)

        high = int(row[1])
        highs.append(high)

    # 根据数据绘制图形
    fig = plt.figure(dpi=128, figsize=(10, 6))
    plt.plot(dates, highs, c=&apos;red&apos;)    # 修改

    --snip--
</code></pre><p>做出来好像不太对劲：</p>
<img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/4.jpg">
<p>日期重叠了。这时候我们可以调用 <code>fig.autofmt_xdate()</code> 来绘制斜的日期标签，以免它们彼此重叠。</p>
<pre><code># 设置图形的格式
plt.title(&quot;Daily high temperatures, July 2014&quot;, fontsize=24)
plt.xlabel(&apos;&apos;, fontsize=16)
fig.autofmt_xdate()    # 新增

--snip--
</code></pre><p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/5.jpg"></p>
<h2 id="涵盖更长时间"><a href="#涵盖更长时间" class="headerlink" title="涵盖更长时间"></a>涵盖更长时间</h2><p>现在，我们可以换另一个文件来读取了：</p>
<pre><code>filename = &apos;sitka_weather_2014.csv&apos;
# 设置图形的格式
plt.title(&quot;Daily high temperatures - 2014&quot;, fontsize=24)
</code></pre><p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/6.jpg"></p>
<h2 id="再绘制一个数据系列"><a href="#再绘制一个数据系列" class="headerlink" title="再绘制一个数据系列"></a>再绘制一个数据系列</h2><p>这时候，我们再导入最低气温数据：</p>
<pre><code>lows = []
for row in reader:
    --snip--
    low = int(row[3])
    lows.append(low)

plt.plot(dates, highs, c=&apos;red&apos;)
plt.plot(dates, lows, c=&apos;blue&apos;)

# 设置图形的格式
plt.title(&quot;Daily high and low temperatures - 2014&quot;, fontsize=24)
</code></pre><p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/7.jpg"></p>
<h2 id="绘图表区域着色"><a href="#绘图表区域着色" class="headerlink" title="绘图表区域着色"></a>绘图表区域着色</h2><p>使用方法 fill_between()，它接受一个 x 值系列和两个 y 值系列，并填充两个 y 值系列之间的空间：</p>
<pre><code>plt.plot(dates, highs, c=&apos;red&apos;, alpha=0.5)
plt.plot(dates, lows, c=&apos;blue&apos;, alpha=0.5)
plt.fill_between(dates, highs, lows, facecolor=&apos;blue&apos;, alpha=0.1)
</code></pre><ul>
<li><code>alpha</code> 指颜色的透明度。Alpha 值为 0 表示完全透明，1（默认设置）表示完全不透明。</li>
</ul>
<img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/8.jpg">
<p>我们看到，在俩温度之间填充了蓝色，并且俩条线颜色变浅了一些。</p>
<h2 id="错误检查"><a href="#错误检查" class="headerlink" title="错误检查"></a>错误检查</h2><p>我们上面引用的数据，都是很全的，但是我们去网上下载数据过来的时候，却不一定有这么全的数据，这时候要学会错误检查。</p>
<pre><code>filename = &apos;death_valley_2014.csv&apos;
</code></pre><p>这是有错误的文件。我们可以看到：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/9.png"></p>
<p>这时候，我们打开 csv 文件就知道了，这里有一天数据全无。它无法导入空字符串。<br>为了解决这种问题，我们用异常处理机制来解决：</p>
<pre><code>for row in reader:
    try:
        low = int(row[3])
        current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)
        high = int(row[1])
    except ValueError:
        print(current_date, &apos;missing data&apos;)
    else:
        lows.append(low)
        dates.append(current_date)
        highs.append(high)
</code></pre><p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/10.png"></p>
<p><strong>感觉不对啊，怎么输出这个？这天不是有数据么？</strong></p>
<p>其实原因在这里：</p>
<pre><code>try:
    low = int(row[3])
    current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)
    high = int(row[1])
</code></pre><p>在这里，先执行 <code>low = int(row[3])</code> ，然后才执行 <code>current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)</code> 语句，这里就出现问题了：<br>本身该行就没有数据，执行前者的时候就报错了，后面的自然就不会执行，所以这时候时间 current_date 还停留在上一个正确的时间，错误的时间并没有导入进 current_date。<br>所以，报错的时候传导的是什么对象，就先把那个对象放在第一行：</p>
<pre><code>try:
    current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)
    low = int(row[3])
    high = int(row[1])
</code></pre><p>再运行一下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/11.png"></p>
<p>运行正确。</p>
<p>其实不仅可以用 try-except-else 代码块来处理异常，在有些情况下，需要使用 continue 来跳过一些数据，或者使用 remove() 或 del 将已提取的数据删除。可采用任何管用的方法，只要能进行精确而有意义的可视化就好。</p>
<h1 id="制作世界人口地图：JSON-格式"><a href="#制作世界人口地图：JSON-格式" class="headerlink" title="制作世界人口地图：JSON 格式"></a>制作世界人口地图：JSON 格式</h1><p>在这一块，我们使用 json 格式的文件来进行数据可视化。</p>
<h2 id="数据提取"><a href="#数据提取" class="headerlink" title="数据提取"></a>数据提取</h2><p>我们打开 json 文件，可以看到：</p>
<pre><code>[
  {
    &quot;Country Name&quot;: &quot;Arab World&quot;,
    &quot;Country Code&quot;: &quot;ARB&quot;,
    &quot;Year&quot;: &quot;1960&quot;,
    &quot;Value&quot;: &quot;96388069&quot;
  },
  {
    &quot;Country Name&quot;: &quot;Arab World&quot;,
    &quot;Country Code&quot;: &quot;ARB&quot;,
    &quot;Year&quot;: &quot;1961&quot;,
    &quot;Value&quot;: &quot;98882541.4&quot;
  },
  --snip--
]
</code></pre><p>它相当于一个长长的 Python 列表，内嵌字典，字典中含有国家名、国别码、年份以及表示人口数量的值。</p>
<p>我们首先先编写打印这些信息的程序：<br><strong>world_population.py</strong></p>
<hr>
<pre><code>import json

# 将数据加载到一个列表中
filename = &apos;population_data.json&apos;
with open (filename) as f:
    pop_data = json.load(f)

# 打印每个国家2010年的人口数量
for pop_dict in pop_data:
    if pop_dict[&apos;Year&apos;] == &apos;2008&apos;:
        country_name = pop_dict[&apos;Country Name&apos;]
        population = pop_dict[&apos;Value&apos;]
        print(country_name + &quot;: &quot; + population)
</code></pre><ul>
<li>函数json.load()将数据转换为Python能够处理的格式，这里是一个列表。</li>
<li>检查字典的’Year’键对应的值是否是2008，这时候用引号括起来，因为观察得知 json 文件内这个是字符串而不是数值。</li>
</ul>
<p>这时候，我们可以看到它的输出：</p>
<pre><code>Arab World: 342077516.074643
Caribbean small states: 6802199
East Asia &amp; Pacific (all income levels): 2172955169.8192
East Asia &amp; Pacific (developing only): 1934412005
Euro area: 329523413

--snip--

Zambia: 12379612
Zimbabwe: 12451543
</code></pre><p>看起来好像正确的。但是还不够，Python 要实现数据可视化需要数值来处理。</p>
<pre><code>population = int(pop_dict[&apos;Value&apos;])
print(country_name + &quot;: &quot; + str(population))
</code></pre><p>出了点问题：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/12.png"></p>
<p>原来还有小数点的限制，但是我们用 float 的话数据有点不好看，全都有小数点，而且对于人口统计这类，还是整数好点。</p>
<p>将  <code>int(pop_dict[&#39;Value&#39;])</code> 变为 <code>int(float(pop_dict[&#39;Value&#39;]))</code></p>
<p>这时候，离制作地图不远了。</p>
<h2 id="获取两个字母的国别码"><a href="#获取两个字母的国别码" class="headerlink" title="获取两个字母的国别码"></a>获取两个字母的国别码</h2><p>制作地图前，还需要解决数据存在的最后一个问题。<br>Pygal 中的地图制作工具要求数据为特定的格式：用国别码表示国家，以及用数字表示人口数量。但是 json 文件中包含的是三个字母的国别码，但 Pygal 使用两个字母的国别码。<br>Pygal 使用的国别码存储在模块 i18n（internationalization 的缩写）中。字典 COUNTRIES 包含的键和值分别为两个字母的国别码和国家名。</p>
<p>现在，我们的做法是，使用自带的国别码与 json 文件的国别码对应：<br><strong>countries.py</strong></p>
<hr>
<pre><code>from pygal.i18n import COUNTRIES

for country_code in sorted(COUNTRIES.keys()):
    print(country_code, COUNTRIES[country_code])
</code></pre><p>sorted()：保留列表原始排序，同时以特定排序呈现原列表。<br>for 循环中，我们让 Python 将键按字母顺序排序（小到大）。</p>
<p>运行后如下：</p>
<pre><code>Traceback (most recent call last):
  File &quot;C:\Users\GR\Desktop\数据可视化\countries.py&quot;, line 1, in &lt;module&gt;
    from pygal.i18n import COUNTRIES
ModuleNotFoundError: No module named &apos;pygal.i18n&apos;
</code></pre><p>这里说没有这个模块？原书中，获取国别码是这个 pygal.i18n ，现在 pygal 没有这个模块了，我们只能这么做：</p>
<p><code>pip install pygal_maps_world</code></p>
<p>安装这个模块，然后将 <code>from pygal.i18n import COUNTRIES</code> 换成 <code>from pygal_maps_world.i18n import COUNTRIES</code> 就行了。<br>后面创建世界地图的时候也是，将库换一下。我们先看看 pygal_maps_world 库里面有什么：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/18.png"></p>
<p>运行后如下：</p>
<pre><code>ad Andorra
ae United Arab Emirates

--snip--

ye Yemen
yt Mayotte
za South Africa
zm Zambia
zw Zimbabwe
</code></pre><p>这时候我们自写一个函数用于国别码的对应：<br><strong>country_codes.py</strong></p>
<hr>
<pre><code>from pygal_maps_world.i18n import COUNTRIES

def get_country_code(country_name):
    &quot;&quot;&quot;根据指定的国家，返回Pygal使用的两个字母的国别码&quot;&quot;&quot;
    for code, name in COUNTRIES.items():
        if name == country_name:
            return code
    # 如果没有找到指定的国家，就返回 None
    return None

print(get_country_code(&apos;Andorra&apos;))
print(get_country_code(&apos;United Arab Emirates&apos;))
print(get_country_code(&apos;Afghanistan&apos;))
</code></pre><p>能正常输出就没问题，接下来删掉 print 语句继续编写（在<strong> world_population.py </strong>文件写）：</p>
<pre><code>from country_codes import get_country_code

--snip--

    population = int(float(pop_dict[&apos;Value&apos;]))
    code = get_country_code(country_name)
    if code:
        print(code + &quot;: &quot; + str(population))
    else:
        print(&apos;ERROR - &apos; + country_name)
</code></pre><p>运行后如下：</p>
<pre><code>ERROR - Arab World
ERROR - Caribbean small states
ERROR - East Asia &amp; Pacific (all income levels)
ERROR - East Asia &amp; Pacific (developing only)

--snip--

zm: 12379612
zw: 12451543
</code></pre><p>有错误信息和正确信息，因为有些统计指全球人口或者地区人口，这些是没有国别码的。现在我们先忽略它。</p>
<h2 id="制作世界地图"><a href="#制作世界地图" class="headerlink" title="制作世界地图"></a>制作世界地图</h2><p>我们跟着书做一个北美地图：<br><strong>americas.py</strong></p>
<hr>
<pre><code>import pygal_maps_world.maps

wm = pygal_maps_world.maps.World()
wm.title = &apos;North, Central, and South America&apos;

wm.add(&apos;North America&apos;, [&apos;ca&apos;, &apos;mx&apos;, &apos;us&apos;])
wm.add(&apos;Central America&apos;, [&apos;bz&apos;, &apos;cr&apos;, &apos;gt&apos;, &apos;hn&apos;, &apos;ni&apos;, &apos;pa&apos;, &apos;sv&apos;])
wm.add(&apos;South America&apos;, [&apos;ar&apos;, &apos;bo&apos;, &apos;br&apos;, &apos;cl&apos;, &apos;co&apos;, &apos;ec&apos;, &apos;gf&apos;,
    &apos;gy&apos;, &apos;pe&apos;, &apos;py&apos;, &apos;sr&apos;, &apos;uy&apos;, &apos;ve&apos;])

wm.render_to_file(&apos;americas.svg&apos;)
</code></pre><ul>
<li>使用方法 add()，它接受一个标签和一个列表，其中后者包含我们要突出的国家的国别码。每次调用 add() 都将为指定的国家选择一种新颜色，并在图表左边显示该颜色和指定的标签。</li>
<li>不过在这里，我们要以同一种颜色显示整个北美地区，因此第一次调用 add() 时，在传递给它的列表中包含 ‘ca’、 ‘mx’ 和 ‘us’，以同时突出加拿大、墨西哥和美国。</li>
</ul>
<p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/13.png"></p>
<h2 id="在世界地图上呈现数字数据"><a href="#在世界地图上呈现数字数据" class="headerlink" title="在世界地图上呈现数字数据"></a>在世界地图上呈现数字数据</h2><p><strong>na_populations.py</strong></p>
<hr>
<pre><code>import pygal_maps_world.maps

wm = pygal_maps_world.maps.World()
wm.title = &apos;Populations of Countries in North America&apos;
wm.add(&apos;North America&apos;, {&apos;ca&apos;: 34126000, &apos;us&apos;: 309349000, &apos;mx&apos;: 113423000})

wm.render_to_file(&apos;na_populations.svg&apos;)
</code></pre><ul>
<li>使用方法 add()，但这次通过第二个实参传递了一个字典而不是列表。</li>
<li>这个字典将两个字母的国别码作为键，将人口数量作为值。</li>
<li>Pygal 根据这些数字自动给不同国家着以深浅不一的颜色（人口最少的国家颜色最浅，人口最多的国家颜色最深）</li>
</ul>
<p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/14.png"></p>
<p>这幅地图具有交互性：如果你将鼠标指向某个国家，将看到其人口数量。下面在这个地图中添加更多的数据。</p>
<h2 id="绘制完整的世界人口地图"><a href="#绘制完整的世界人口地图" class="headerlink" title="绘制完整的世界人口地图"></a>绘制完整的世界人口地图</h2><p>把这个北美地图弄出来，世界地图也就不远了。<br>跳转到 <strong>world_population.py</strong>：</p>
<pre><code>import pygal_maps_world.maps

# 创建一个包含人口数量的字典
cc_populations = {}

--snip--

    code = get_country_code(country_name)
    if code:
        cc_populations[code] = population

wm = pygal_maps_world.maps.World()
wm.title = &apos;World Population in 2008, by Country&apos;
wm.add(&apos;2008&apos;, cc_populations)

wm.render_to_file(&apos;world_population.svg&apos;)
</code></pre><p>这里记得把之前的 print 语句删掉。</p>
<p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/15.png"></p>
<p>可以看到有些国家或地区没有统计到，这是因为上述没有国别码的原因造成的。现在先不管。</p>
<h2 id="根据人口数量将国家分组"><a href="#根据人口数量将国家分组" class="headerlink" title="根据人口数量将国家分组"></a>根据人口数量将国家分组</h2><p>看看地图，中国人口这么多，但是直观上看感觉好像没多到哪里去？为了突出这一点，我们将人口数量分成三组——少于 1000 万的、介于 1000 万和 10 亿之间的以及超过 10 亿的：</p>
<pre><code># 根据人口数量将所有的国家分成三组
cc_pops_1, cc_pops_2, cc_pops_3 = {}, {}, {}
for cc, pop in cc_populations.items():
    if pop &lt; 10000000:
        cc_pops_1[cc] = pop
    elif pop &lt; 1000000000:
        cc_pops_2[cc] = pop
    else:
        cc_pops_3[cc] = pop

# 看看每组分别包含多少个国家
print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))

wm.title = &apos;World Population in 2008, by Country&apos;
wm.add(&apos;0-10m&apos;, cc_pops_1)
wm.add(&apos;10m-1bn&apos;, cc_pops_2)
wm.add(&apos;&gt;1bn&apos;, cc_pops_3)
</code></pre><p>运行后如下：<br>    85 69 2<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/16.png"></p>
<p>这样看起来就比较清晰了，但是我想让超过 10 亿人口的国家颜色为红色，怎么弄？</p>
<h2 id="使用-pygal-设置世界地图的样式"><a href="#使用-pygal-设置世界地图的样式" class="headerlink" title="使用 pygal 设置世界地图的样式"></a>使用 pygal 设置世界地图的样式</h2><pre><code>from pygal.style import RotateStyle

wm_style = RotateStyle(&apos;#336699&apos;)
wm = pygal_maps_world.maps.World(style=wm_style)
</code></pre><p>Pygal 样式存储在模块 style 中（这里注意下，不在 pygal_maps_world 库里面），我们从这个模块中导入了样式 RotateStyle ，这个实例需要一个实参——十六进制的 RGB 颜色。</p>
<p>十六进制格式的 RGB 颜色是一个以井号（#）打头的字符串，后面跟着6个字符，其中前两个字符表示红色分量，接下来的两个表示绿色分量，最后两个表示蓝色分量。每个分量<br>的取值范围为 00（没有相应的颜色）~FF（包含最多的相应颜色）。如果你在线搜索 hex color chooser （十六进制颜色选择器），可找到让你能够尝试选择不同的颜色并显示其 RGB 值的工具。</p>
<p>运行后如下：<br><img src="/ganru.github.io/2018/10/24/数据可视化（第二部分）/17.png"></p>
<h2 id="加亮颜色主题"><a href="#加亮颜色主题" class="headerlink" title="加亮颜色主题"></a>加亮颜色主题</h2><p>Pygal 通常默认使用较暗的颜色主题。有时候为了方便印刷，得使用 LightColorizedStyle 加亮地图的颜色。这个类修改整个图表的主题，包括背景色、标签以及各个国家的颜色。要使用这个样式，先导入它：</p>
<p><code>from pygal.style import LightColorizedStyle as LCS</code></p>
<p>然后就可独立地使用 LightColorizedStyle 了，例如：</p>
<p><code>wm_style = LCS</code></p>
<p>然而使用这个类时，你不能直接控制使用的颜色， Pygal 将选择默认的基色。要设置颜色，可使用 RotateStyle，并将 LightColorizedStyle 作为基本样式。</p>
<p>wm_style = RotateStyle(‘#336699’, base_style=LightColorizedStyle)</p>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><ol>
<li>如何使用网上的数据集</li>
<li>如何处理CSV和JSON文件，以及如何提取你感兴趣的数据</li>
<li>如何使用 matplotlib 来处理以往的天气数据，包括如何使用模块 datetime，以及如何在同一个图表中绘制多个数据系列</li>
<li>如何使用 Pygal 绘制呈现各国数据的世界地图，以及如何设置 Pygal 地图和图表的样式</li>
</ol>
<h1 id="各部分源码"><a href="#各部分源码" class="headerlink" title="各部分源码"></a>各部分源码</h1><h2 id="highs-lows-py"><a href="#highs-lows-py" class="headerlink" title="highs_lows.py"></a>highs_lows.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import csv</span><br><span class="line">from datetime import datetime</span><br><span class="line"></span><br><span class="line">from matplotlib import pyplot as plt</span><br><span class="line"></span><br><span class="line">filename = &apos;death_valley_2014.csv&apos;</span><br><span class="line">with open(filename) as f:</span><br><span class="line">	reader = csv.reader(f)</span><br><span class="line">	header_row = next(reader)</span><br><span class="line">	</span><br><span class="line">	for index, column_header in enumerate(header_row):</span><br><span class="line">		print(index, column_header)</span><br><span class="line">	</span><br><span class="line">	highs = []</span><br><span class="line">	dates = []</span><br><span class="line">	lows = []</span><br><span class="line">	for row in reader:</span><br><span class="line">		try:</span><br><span class="line">			current_date = datetime.strptime(row[0], &quot;%Y-%m-%d&quot;)</span><br><span class="line">			low = int(row[3])</span><br><span class="line">			high = int(row[1])</span><br><span class="line">		except ValueError:</span><br><span class="line">			print(current_date, &apos;missing data&apos;)</span><br><span class="line">		else:</span><br><span class="line">			lows.append(low)</span><br><span class="line">			dates.append(current_date)</span><br><span class="line">			highs.append(high)</span><br><span class="line">	</span><br><span class="line"># 根据数据绘制图形</span><br><span class="line">fig = plt.figure(dpi=128, figsize=(10, 6))</span><br><span class="line">plt.plot(dates, highs, c=&apos;red&apos;, alpha=0.5)</span><br><span class="line">plt.plot(dates, lows, c=&apos;blue&apos;, alpha=0.5)</span><br><span class="line">plt.fill_between(dates, highs, lows, facecolor=&apos;blue&apos;, alpha=0.1)</span><br><span class="line"></span><br><span class="line"># 设置图形的格式</span><br><span class="line">plt.title(&quot;Daily high and low temperatures - 2014&quot;, fontsize=24)</span><br><span class="line">plt.xlabel(&apos;&apos;, fontsize=16)</span><br><span class="line">fig.autofmt_xdate()</span><br><span class="line">plt.ylabel(&quot;Temperature (F)&quot;, fontsize=16)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="world-population-py"><a href="#world-population-py" class="headerlink" title="world_population.py"></a>world_population.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line">import pygal_maps_world.maps</span><br><span class="line">import pygal</span><br><span class="line">from pygal.style import RotateStyle as RS, LightColorizedStyle as LCS</span><br><span class="line"></span><br><span class="line">from country_codes import get_country_code</span><br><span class="line"></span><br><span class="line"># 将数据加载到一个列表中</span><br><span class="line">filename = &apos;population_data.json&apos;</span><br><span class="line">with open (filename) as f:</span><br><span class="line">	pop_data = json.load(f)</span><br><span class="line">	</span><br><span class="line"># 创建一个包含人口数量的字典</span><br><span class="line">cc_populations = &#123;&#125;</span><br><span class="line"></span><br><span class="line"># 打印每个国家 2008 年的人口数量</span><br><span class="line">for pop_dict in pop_data:</span><br><span class="line">	if pop_dict[&apos;Year&apos;] == &apos;2008&apos;:</span><br><span class="line">		country_name = pop_dict[&apos;Country Name&apos;]</span><br><span class="line">		population = int(float(pop_dict[&apos;Value&apos;]))</span><br><span class="line">		code = get_country_code(country_name)</span><br><span class="line">		if code:</span><br><span class="line">			cc_populations[code] = population</span><br><span class="line"></span><br><span class="line"># 根据人口数量将所有的国家分成三组</span><br><span class="line">cc_pops_1, cc_pops_2, cc_pops_3 = &#123;&#125;, &#123;&#125;, &#123;&#125;</span><br><span class="line">for cc, pop in cc_populations.items():</span><br><span class="line">	if pop &lt; 10000000:</span><br><span class="line">		cc_pops_1[cc] = pop</span><br><span class="line">	elif pop &lt; 1000000000:</span><br><span class="line">		cc_pops_2[cc] = pop</span><br><span class="line">	else:</span><br><span class="line">		cc_pops_3[cc] = pop</span><br><span class="line"></span><br><span class="line"># 看看每组分别包含多少个国家</span><br><span class="line">print(len(cc_pops_1), len(cc_pops_2), len(cc_pops_3))</span><br><span class="line"></span><br><span class="line"># 自定义地图的颜色样式，并高亮颜色</span><br><span class="line">wm_style = RS(&apos;#336699&apos;, base_style=LCS)</span><br><span class="line">wm = pygal_maps_world.maps.World(style=wm_style)</span><br><span class="line">wm.title = &apos;World Population in 2008, by Country&apos;</span><br><span class="line">wm.add(&apos;0-10m&apos;, cc_pops_1)</span><br><span class="line">wm.add(&apos;10m-1bn&apos;, cc_pops_2)</span><br><span class="line">wm.add(&apos;&gt;1bn&apos;, cc_pops_3)</span><br><span class="line"></span><br><span class="line">wm.render_to_file(&apos;world_population.svg&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="country-codes-py"><a href="#country-codes-py" class="headerlink" title="country_codes.py"></a>country_codes.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from pygal_maps_world.i18n import COUNTRIES</span><br><span class="line"></span><br><span class="line">def get_country_code(country_name):</span><br><span class="line">	&quot;&quot;&quot;根据指定的国家，返回 Pygal 使用的两个字母的国别码&quot;&quot;&quot;</span><br><span class="line">	for code, name in COUNTRIES.items():</span><br><span class="line">		if name == country_name:</span><br><span class="line">			return code</span><br><span class="line">	# 如果没有找到指定的国家，就返回 None</span><br><span class="line">	return None</span><br></pre></td></tr></table></figure>
<h2 id="americas-py"><a href="#americas-py" class="headerlink" title="americas.py"></a>americas.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import pygal_maps_world.maps</span><br><span class="line"></span><br><span class="line">wm = pygal_maps_world.maps.World()</span><br><span class="line">wm.title = &apos;North, Central, and South America&apos;</span><br><span class="line"></span><br><span class="line">wm.add(&apos;North America&apos;, [&apos;ca&apos;, &apos;mx&apos;, &apos;us&apos;])</span><br><span class="line">wm.add(&apos;Central America&apos;, [&apos;bz&apos;, &apos;cr&apos;, &apos;gt&apos;, &apos;hn&apos;, &apos;ni&apos;, &apos;pa&apos;, &apos;sv&apos;])</span><br><span class="line">wm.add(&apos;South America&apos;, [&apos;ar&apos;, &apos;bo&apos;, &apos;br&apos;, &apos;cl&apos;, &apos;co&apos;, &apos;ec&apos;, &apos;gf&apos;,</span><br><span class="line">	&apos;gy&apos;, &apos;pe&apos;, &apos;py&apos;, &apos;sr&apos;, &apos;uy&apos;, &apos;ve&apos;])</span><br><span class="line"></span><br><span class="line">wm.render_to_file(&apos;americas.svg&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="na-populations-py"><a href="#na-populations-py" class="headerlink" title="na_populations.py"></a>na_populations.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import pygal_maps_world.maps</span><br><span class="line"></span><br><span class="line">wm = pygal_maps_world.maps.World()</span><br><span class="line">wm.title = &apos;Populations of Countries in North America&apos;</span><br><span class="line">wm.add(&apos;North America&apos;, &#123;&apos;ca&apos;: 34126000, &apos;us&apos;: 309349000, &apos;mx&apos;: 113423000&#125;)</span><br><span class="line"></span><br><span class="line">wm.render_to_file(&apos;na_populations.svg&apos;)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/10/19/数据可视化（第一部分）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/10/19/数据可视化（第一部分）/" itemprop="url">数据可视化（第一部分）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-19T21:54:28+08:00">
                2018-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<p>数据可视化指的是通过可视化表示来探索数据，它与数据挖掘紧密相关，而数据挖掘指的是使用代码来探索数据集的规律和关联。数据集可以是用一行代码就能表示的小型数字列表，也可以是数以几字节的数据。</p>
<blockquote>
<p><strong>项目简介：</strong></p>
<hr>
<p><em>基于随机漫步概念生成一个更有趣的数据集——根据一系列随机决策生成的图表。</em><br><em>通过使用</em> <em>Pygal，可在用户与图表交互时突出元素以及调整其大小，还可轻松地调整整个图表的尺寸，使其适合在微型智能手表或巨型显示器上显示。使用</em> <em>Pygal</em> <em>以各种方式探索掷骰子的结果。</em></p>
</blockquote>
<p>准备工作：</p>
<ol>
<li>安装 matplotlib 库<br>打开 cmd，用命令 <code>pip install matplotlib</code> 安装。</li>
<li>安装 pygal 库<br>打开 cmd，用命令 <code>pip install pygal</code> 安装。</li>
</ol>
<h1 id="绘制简单的折线图"><a href="#绘制简单的折线图" class="headerlink" title="绘制简单的折线图"></a>绘制简单的折线图</h1><p>安装好 matplotlib 库之后，我们简单的测试一下看看怎么用：<br><strong>mpl_squares.py</strong></p>
<hr>
<pre><code>import matplotlib.pyplot as plt

squares = [1, 4, 9, 16, 25]

plt.plot(squares)
plt.show()
</code></pre><p><code>plt.plot(squares)</code>：尝试根据这些数字绘制出有意义的图形<br><code>plt.show()</code>：打开matplotlib查看器，并显示绘制的图形<br>运行后如下图所示：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/1.png"></p>
<h2 id="标签文字与线条粗细的修改"><a href="#标签文字与线条粗细的修改" class="headerlink" title="标签文字与线条粗细的修改"></a>标签文字与线条粗细的修改</h2><p>有没有觉得上图字体太小？眼睛怕是要瞎了。</p>
<pre><code>import matplotlib.pyplot as plt

# 这一部分可视情况而添加，用于显示中文
from pylab import mpl  
mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]


squares = [1, 4, 9, 16, 25]
plt.plot(squares, linewidth=5)

# 设置图表标题，并给坐标轴加上标签
plt.title(&quot;平方数列&quot;, fontsize=24)
plt.xlabel(&quot;值 &quot;, fontsize=14)
plt.ylabel(&quot;值的平方&quot;, fontsize=14)

# 设置刻度标记的大小
plt.tick_params(axis=&apos;both&apos;, labelsize=14)

plt.show()
</code></pre><p>运行后效果如下：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/2.jpg"></p>
<p><code>axis=&#39;both&#39;</code> 表示坐标刻度样式，<code>labelsize=14</code> 表示坐标刻度字体大小。</p>
<p>注意：<br>x 轴标签显示可能有问题，如果字体显示不完整，在字符结尾添加空格符。（可能是中文字符问题，英文字符无须如此操作）</p>
<h2 id="图形校正"><a href="#图形校正" class="headerlink" title="图形校正"></a>图形校正</h2><p>不知你们有没有注意到，4 的平方图像显示是 25。这是因为当我们向 plot() 提供一系列数字时，它假设第一个数据点对应的 x 坐标值为 0，但我们的第一个点对应的 x 值为 1。<br>为了改变这种行为，我们可以先加一些限定：</p>
<pre><code>import matplotlib.pyplot as plt

input_values = [1, 2, 3, 4, 5]
squares = [1, 4, 9, 16, 25]
plt.plot(input_values, squares, linewidth=5)

# 设置图表标题并给坐标轴加上标签
--snip--
</code></pre><p>给 plot() 同时提供输入值和输出值。</p>
<h2 id="使用-scatter-绘制散点图并设置其样式"><a href="#使用-scatter-绘制散点图并设置其样式" class="headerlink" title="使用 scatter() 绘制散点图并设置其样式"></a>使用 scatter() 绘制散点图并设置其样式</h2><p>有些数据可能不适合呈现出折线效果，像无规律离散视图，那么针对这种问题，我们可以用函数 scatter() 呈现。<br><strong>scatter_squares.py</strong></p>
<hr>
<pre><code>import matplotlib.pyplot as plt

plt.scatter(2, 4)
plt.show()
</code></pre><p>运行后效果如下：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/3.jpg"></p>
<p>图像有点无趣，加点功能：</p>
<pre><code>import matplotlib.pyplot as plt

from pylab import mpl  
mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]

plt.scatter(2, 4, s=200)

# 设置图表标题并给坐标轴加上标签
plt.title(&quot;平方数列&quot;, fontsize=24)
plt.xlabel(&quot;值 &quot;, fontsize=14)
plt.ylabel(&quot;值的平方&quot;, fontsize=14)

# 设置刻度标记的大小
plt.tick_params(axis=&apos;both&apos;, which=&apos;major&apos;, labelsize=14)

plt.show()
</code></pre><p><code>plt.scatter(2, 4, s=200)</code>：使用实参 s 设置了绘制图形时使用的点的尺寸</p>
<p>运行后效果如下：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/4.jpg"></p>
<h2 id="用-scatter-进行多点绘制"><a href="#用-scatter-进行多点绘制" class="headerlink" title="用 scatter() 进行多点绘制"></a>用 scatter() 进行多点绘制</h2><p>知道怎么画点后，我们画多个点：</p>
<pre><code>from pylab import mpl  
mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]

x_values = [1, 2, 3, 4, 5]
y_values = [1, 4, 9, 16, 25]

plt.scatter(x_values, y_values, s=100)

--snip--
</code></pre><p>运行后效果如下：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/5.jpg"></p>
<h2 id="自动计算数据"><a href="#自动计算数据" class="headerlink" title="自动计算数据"></a>自动计算数据</h2><p>现在知道怎么绘制离散点，但都是我们给定准确数值而画的，现在让 Python 自动计算数据：</p>
<pre><code>from pylab import mpl  
mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]

x_values = list(range(1, 1001))
y_values = [x**2 for x in x_values]

plt.scatter(x_values, y_values, s=40)

# 设置每个坐标轴的取值范围
plt.axis([0, 1100, 0, 1100000])

--snip--
</code></pre><p>运行后效果如下：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/6.jpg"></p>
<p>有点怪怪的啊，好像生成了一条线？（点太多了哈哈）<br>函数 axis() 要求提供四个值： x 和 y 坐标轴的 <strong>最小值</strong> 和 <strong>最大值</strong>。</p>
<h2 id="删除数据点的轮廓"><a href="#删除数据点的轮廓" class="headerlink" title="删除数据点的轮廓"></a>删除数据点的轮廓</h2><p>仔细看上图，是否发现，这些大量的点粘连在一起，虽然组成了线段但是还是有点不光滑？<br>是因为 matplotlib 给散点图中的各个点指定颜色，默认为蓝色点和黑色轮廓，在散点图包含的数据点不多时效果很好，但是点多的话就不太好了。</p>
<p><code>plt.scatter(x_values, y_values, edgecolor=&#39;none&#39;, s=40)</code></p>
<p>加上 <code>edgecolor=&#39;none&#39;</code> 这个参数，就可以删除这些轮廓，使线段变得光滑。<strong>如果数据点不多就无需这么做了。</strong><br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/7.jpg"></p>
<h2 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h2><p>要修改数据点的颜色，可向 scatter() 传递参数 c，并将其设置为要使用的颜色的名称，如下：</p>
<p><code>plt.scatter(x_values, y_values, c=&#39;red&#39;, edgecolor=&#39;none&#39;, s=40)</code></p>
<p>当然，我们也还可以用 RGB 颜色模式自定义：</p>
<p><code>c=(0, 0, 0.8)</code></p>
<p>注意 c 的元组内各元素取值范围为 <strong>0 ~ 1</strong> 之间。分别表示 红色、绿色 和 蓝色 分量。值越接近 0，指定的颜色越深，值越接近 1，指定的颜色越浅。</p>
<h2 id="使用颜色映射"><a href="#使用颜色映射" class="headerlink" title="使用颜色映射"></a>使用颜色映射</h2><p>颜色映射（colormap）：是一系列颜色，它们从起始颜色渐变到结束颜色。在可视化中，颜色映射用于突出<strong>数据的规律</strong>，例如，你可能用较浅的颜色来显示较小的值，并使用较深的颜色来显示较大的值。</p>
<p><code>plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, edgecolor=&#39;none&#39;, s=40)</code></p>
<p>我们将参数 c 设置成了一个 y 值列表，并使用参数 cmap 告诉 pyplot 使用哪个颜色映射。<br>参数 cmap 要配合 c 使用，不然不知道怎么分配颜色。</p>
<img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/8.jpg">
<h2 id="自动保存图表"><a href="#自动保存图表" class="headerlink" title="自动保存图表"></a>自动保存图表</h2><p>绘制好图像后，如果想要保存图像，那么老是截图就不好玩了，将对 plt.show() 的调用替换为对 plt.savefig() 的调用：</p>
<p>将 <code>plt.show()</code> 替换为 <code>plt.savefig(&#39;squares_plot.png&#39;, bbox_inches=&#39;tight&#39;)</code></p>
<p>它会自动生成图像保存在 .py 文件所在目录中。第二个实参指定将图表多余的空白区域裁剪掉。</p>
<h1 id="随机漫步"><a href="#随机漫步" class="headerlink" title="随机漫步"></a>随机漫步</h1><p>随机漫步很有用处，比如我们抛硬币，正面出现多少次，反面出现多少次，全部由系统随机漫步生成，当然也远不仅如此。<br>我们模拟一下随机漫步的过程。</p>
<h2 id="创建-RandomWalk-类"><a href="#创建-RandomWalk-类" class="headerlink" title="创建 RandomWalk() 类"></a>创建 RandomWalk() 类</h2><p>创建 RandomWalk() 类，它随机选择前进的方向。这个类需要三个属性，其中一个是存储随机漫步次数的变量，其他两个是列表，分别存储随机漫步经过的每个点的 x 和 y 坐标。<br><strong>random_walk.py</strong></p>
<hr>
<pre><code>from random import choice

class RandomWalk():
    &quot;&quot;&quot;一个生成随机漫步的类&quot;&quot;&quot;

    def __init__(self, num_points=5000):
        &quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot;
        self.num_points = num_points

        # 所有随机漫步都始于（0，0）
        self.x_values = [0]
        self.y_values = [0]
</code></pre><p>每次做决策时都使用 choice() 来决定使用哪种选择。<br>漫步 5K 次，并设定漫步初始坐标。</p>
<h2 id="选择方向"><a href="#选择方向" class="headerlink" title="选择方向"></a>选择方向</h2><p>我们将使用 fill_walk() 来生成漫步包含的点，并决定每次漫步的方向，如下：</p>
<pre><code>def fill_walk(self):
    &quot;&quot;&quot;计算随机漫步包含的所有点&quot;&quot;&quot;

    # 不断漫步，直到达到指定的长度
    while len(self.x_values) &lt; self.num_points:

        # 决定前进方向以及沿这个方向前进的距离
        x_direction = choice([1, -1])
        x_distance = choice([0, 1, 2, 3, 4])
        x_step = x_direction * x_distance

        y_direction = choice([1, -1])
        y_distance = choice([0, 1, 2, 3, 4])
        y_step = y_direction * y_distance

        # 拒绝原地踏步
        if x_step == 0 and y_step == 0:
            continue

        # 计算下一个点的 x 、y 坐标 ([-1] 指列表最后一个元素)
        next_x = self.x_values[-1] + x_step
        next_y = self.y_values[-1] + y_step

        self.x_values.append(next_x)
        self.y_values.append(next_y)
</code></pre><h2 id="绘制随机漫步图"><a href="#绘制随机漫步图" class="headerlink" title="绘制随机漫步图"></a>绘制随机漫步图</h2><p><strong>rw_visual.py</strong></p>
<hr>
<pre><code>import matplotlib.pyplot as plt

from random_walk import RandomWalk

# 创建一个RandomWalk实例，并将其包含的点都绘制出来
rw = RandomWalk()
rw.fill_walk()
plt.scatter(rw.x_values, rw.y_values, s=15)
plt.show()
</code></pre><p>运行后效果如下：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/9.jpg"></p>
<p>不过刚开始运行的时候，可能会碰到这个问题：</p>
<p><code>SyntaxError: unexpected EOF while parsing</code></p>
<p>关掉在运行一遍即可，如果还有，那可能就是代码错误（eg：语法有问题、PY3 的代码在 PY2 中运行）</p>
<h2 id="模拟多次随机漫步"><a href="#模拟多次随机漫步" class="headerlink" title="模拟多次随机漫步"></a>模拟多次随机漫步</h2><p>如果我们想多次进行随机漫步，可以把这些代码加入 while 循环：</p>
<pre><code>while True：
    # 创建一个RandomWalk实例，并将其包含的点都绘制出来
    rw = RandomWalk()
    rw.fill_walk()
    plt.scatter(rw.x_values, rw.y_values, s=15)
    plt.show()

    keep_running = input(&quot;Make another walk? (y/n): &quot;)
    if keep_running == &apos;n&apos;:
        break
</code></pre><h2 id="设置随机漫步图的样式"><a href="#设置随机漫步图的样式" class="headerlink" title="设置随机漫步图的样式"></a>设置随机漫步图的样式</h2><p>我们定制图表，以突出每次漫步的重要特征，并让分散注意力的元素不那么显眼。为此，我们确定要突出的元素，如漫步的起点、终点和经过的路径。</p>
<h3 id="给点着色"><a href="#给点着色" class="headerlink" title="给点着色"></a>给点着色</h3><p>在这里，我们要删除每个点的黑色轮廓、让最近的漫步颜色渐深：</p>
<pre><code>while True:
# 创建一个RandomWalk实例，并将其包含的点都绘制出来
rw = RandomWalk()
rw.fill_walk()

point_numbers = list(range(rw.num_points))
plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, edgecolor=&apos;none&apos;, s=15)
</code></pre><p>运行后如下图所示：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/10.jpg"></p>
<h3 id="重新绘制起点与终点"><a href="#重新绘制起点与终点" class="headerlink" title="重新绘制起点与终点"></a>重新绘制起点与终点</h3><p>我们让起点和终点变得更大，并显示为不同的颜色，以突出它们：</p>
<pre><code># 突出起点和终点
plt.scatter(0, 0, c=&apos;green&apos;, edgecolors=&apos;none&apos;, s=100)
plt.scatter(rw.x_values[-1], rw.y_values[-1], c=&apos;red&apos;, edgecolors=&apos;none&apos;, s=100)
</code></pre><h3 id="隐藏坐标轴"><a href="#隐藏坐标轴" class="headerlink" title="隐藏坐标轴"></a>隐藏坐标轴</h3><p>为了让观察者注意力更好的放在路径上而不会分散一些注意力在坐标轴上，我们可以认为隐藏坐标轴：</p>
<pre><code># 隐藏坐标轴
plt.axes().get_xaxis().set_visible(False)
plt.axes().get_yaxis().set_visible(False)
</code></pre><p>运行后如下图所示：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/11.jpg"></p>
<h3 id="增加点数"><a href="#增加点数" class="headerlink" title="增加点数"></a>增加点数</h3><p>这次我们可以尝试将漫步次数加到 5W 次，不过记得让点的尺寸 (s) 变小一点。</p>
<h3 id="调整窗口尺寸"><a href="#调整窗口尺寸" class="headerlink" title="调整窗口尺寸"></a>调整窗口尺寸</h3><pre><code># 设置绘图窗口的尺寸
plt.figure(dpi=128, figsize=(10, 6))
</code></pre><ol>
<li>函数figure()用于指定图表的宽度、高度、分辨率和背景色。单位为 英寸。</li>
<li>Python 假定屏幕分辨率为 80 像素/英寸，如果上述代码指定的图表尺寸不合适，可根据需要调整其中的数字。</li>
<li>如果你知道自己的系统的分辨率，可使用形参 dpi 向 figure() 传递该分辨率（书中原话，不过我试验的时候用 1080 ，崩了，所以还是建议别传这么大的值）</li>
</ol>
<h3 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h3><p>有没有感觉 fill_walk() 有点长？试试重构？</p>
<pre><code>def fill_walk(self):
    &quot;&quot;&quot;计算随机漫步包含的所有点&quot;&quot;&quot;

    # 不断漫步，直到达到指定的长度
    while len(self.x_values) &lt; self.num_points:

        # 决定前进方向以及沿这个方向前进的距离
        x_step = self.get_step()
        y_step = self.get_step()

        # 拒绝原地踏步
        if x_step == 0 and y_step == 0:
            continue

        # 计算下一个点的 x 、y 坐标 ([-1] 指列表最后一个元素)
        next_x = self.x_values[-1] + x_step
        next_y = self.y_values[-1] + y_step

        self.x_values.append(next_x)
        self.y_values.append(next_y)

def get_step(self):
    &quot;&quot;&quot;计算下一个点的可能前进距离&quot;&quot;&quot;
    direction = choice([1, -1])
    distance = choice([0, 1, 2, 3, 4])
    step = direction * distance
    return step
</code></pre><h1 id="使用-Pygal-模拟掷骰子"><a href="#使用-Pygal-模拟掷骰子" class="headerlink" title="使用 Pygal 模拟掷骰子"></a>使用 Pygal 模拟掷骰子</h1><p>我们将使用 Python 可视化包 Pygal 来生成可缩放的矢量图形文件。对于需要在尺寸不同的屏幕上显示的图表，这很有用，因为它们将自动缩放，以适合观看者的屏幕。</p>
<p>在此之前我们要先安装 Pygal 库：</p>
<p><code>pip install pygal</code></p>
<h2 id="创建-Die-类"><a href="#创建-Die-类" class="headerlink" title="创建 Die 类"></a>创建 Die 类</h2><p><strong>die.py</strong></p>
<hr>
<pre><code>from random import randint

class Die():
    &quot;&quot;&quot;表示一个骰子的类&quot;&quot;&quot;

    def __init__(self, num_sides=6):
        &quot;&quot;&quot;骰子有几面，不导入实参就默认六面&quot;&quot;&quot;
        self.num_sides = num_sides

    def roll(self):
        &quot;&quot;&quot;返回一个位于1和骰子面数之间的随机值&quot;&quot;&quot;
        return randint(1, self.num_sides)
</code></pre><p>函数 randint() 来返回一个 1 和面数之间的随机数。</p>
<h2 id="掷骰子"><a href="#掷骰子" class="headerlink" title="掷骰子"></a>掷骰子</h2><p><strong>die_visual.py</strong></p>
<hr>
<pre><code>from die import Die

# 创建一个D6
die = Die()

# 掷几次骰子，并将结果存储在一个列表中
results = []
for roll_num in range(1000):
    result = die.roll()
    results.append(result)

print(results)
</code></pre><p>检验一下，输出大概没问题（有 1、6 也有 1 ~ 6 之间的数，没有其他数）</p>
<h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>为分析掷一个D6骰子的结果，我们计算每个点数出现的次数：</p>
<pre><code># 分析结果
frequencies = []
for value in range(1, die.num_sides+1):
    frequency = results.count(value)
    frequencies.append(frequency)

print(frequencies)
</code></pre><p>会看到这样的结果：</p>
<pre><code>[173, 161, 165, 181, 158, 162]
</code></pre><p>很合理，并没有哪个点超出某个点很多。接下来我们可视化这些数据。</p>
<h2 id="绘制直方图"><a href="#绘制直方图" class="headerlink" title="绘制直方图"></a>绘制直方图</h2><p>有了上面提供的频率列表，绘制直方图就比较容易了。</p>
<pre><code># 对结果进行可视化成条形图
hist = pygal.Bar()

hist.title = &quot;Results of rolling one D6 1000 times.&quot;
hist.x_labels = [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;]
hist.x_title = &quot;Results&quot;
hist.y_title = &quot;Frequency of Result&quot;

# 添加数据， 第一个参数是数据的标题
hist.add(&apos;D6&apos;, frequencies)
# 保存到本地，格式必须是 svg
hist.render_to_file(&apos;die_visual.svg&apos;)
</code></pre><h2 id="同时掷两个骰子"><a href="#同时掷两个骰子" class="headerlink" title="同时掷两个骰子"></a>同时掷两个骰子</h2><p>做两个骰子试下，，并将这两个得到的数值相加：</p>
<pre><code># 创建两个D6骰子
die_1 = Die()
die_2 = Die()
</code></pre><p>不过这样子得改动一下，毕竟最小值是 2，最大 12：</p>
<pre><code># 掷几次骰子，并将结果存储在一个列表中
results = []
for roll_num in range(1000):
    result = die_1.roll() + die_2.roll()
    results.append(result)

# 分析结果
frequencies = []
max_result = die_1.num_sides + die_2.num_sides
# 这里尽量别写 range(2, 13)，我们要保证代码可适用于更多不同的面
for value in range(2, max_result+1):
    frequency = results.count(value)
    frequencies.append(frequency)

# 对结果进行可视化
hist = pygal.Bar()

hist.title = &quot;Results of rolling two D6 dice 1000 times.&quot;
hist.x_labels = [&apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;10&apos;, &apos;11&apos;, &apos;12&apos;]
hist.x_title = &quot;Results&quot;
hist.y_title = &quot;Frequency of Result&quot;

hist.add(&apos;D6 + D6&apos;, frequencies)
</code></pre><p>运行后如下图所示：<br><img src="/ganru.github.io/2018/10/19/数据可视化（第一部分）/12.jpg"></p>
<h2 id="多面骰子"><a href="#多面骰子" class="headerlink" title="多面骰子"></a>多面骰子</h2><p><code>die_2 = Die(10)</code> 这样子试试？</p>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><ol>
<li>如何生成数据集以及如何对其进行可视化</li>
<li>折线图的绘制 <em>plt.plot()</em></li>
<li>散点图的绘制 <em>plt.scatter()</em></li>
<li>用随机漫步数据绘制散点图</li>
<li>直方图的绘制 <em>pygal.Bar()</em></li>
</ol>
<h1 id="各组件源码"><a href="#各组件源码" class="headerlink" title="各组件源码"></a>各组件源码</h1><h2 id="mpl-squares-py"><a href="#mpl-squares-py" class="headerlink" title="mpl_squares.py"></a>mpl_squares.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from pylab import mpl  </span><br><span class="line">mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]</span><br><span class="line"></span><br><span class="line">input_values = [1, 2, 3, 4, 5]</span><br><span class="line">squares = [1, 4, 9, 16, 25]</span><br><span class="line">plt.plot(input_values, squares, linewidth=5)</span><br><span class="line"></span><br><span class="line"># 设置图表标题，并给坐标轴加上标签</span><br><span class="line">plt.title(&quot;平方数列&quot;, fontsize=24)</span><br><span class="line">plt.xlabel(&quot;值 &quot;, fontsize=14)</span><br><span class="line">plt.ylabel(&quot;值的平方&quot;, fontsize=14)</span><br><span class="line"></span><br><span class="line"># 设置刻度标记的大小</span><br><span class="line">plt.tick_params(axis=&apos;both&apos;, labelsize=14)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<h2 id="scatter-squares-py"><a href="#scatter-squares-py" class="headerlink" title="scatter_squares.py"></a>scatter_squares.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from pylab import mpl  </span><br><span class="line">mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]</span><br><span class="line"></span><br><span class="line">x_values = list(range(1, 1001))</span><br><span class="line">y_values = [x**2 for x in x_values]</span><br><span class="line"></span><br><span class="line">plt.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, edgecolor=&apos;none&apos;, s=40)</span><br><span class="line"></span><br><span class="line"># 设置图表标题并给坐标轴加上标签</span><br><span class="line">plt.title(&quot;平方数列&quot;, fontsize=24)</span><br><span class="line">plt.xlabel(&quot;值 &quot;, fontsize=14)</span><br><span class="line">plt.ylabel(&quot;值的平方&quot;, fontsize=14)</span><br><span class="line"></span><br><span class="line"># 设置刻度标记的大小</span><br><span class="line">plt.tick_params(axis=&apos;both&apos;, which=&apos;major&apos;, labelsize=14)</span><br><span class="line"></span><br><span class="line"># 设置每个坐标轴的取值范围</span><br><span class="line">plt.axis([0, 1100, 0, 1100000])</span><br><span class="line"></span><br><span class="line">plt.savefig(&apos;squares_plot.png&apos;, bbox_inches=&apos;tight&apos;)</span><br></pre></td></tr></table></figure>
<h2 id="random-walk-py"><a href="#random-walk-py" class="headerlink" title="random_walk.py"></a>random_walk.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">from random import choice</span><br><span class="line"></span><br><span class="line">class RandomWalk():</span><br><span class="line">	&quot;&quot;&quot;一个生成随机漫步的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, num_points=50000):</span><br><span class="line">		&quot;&quot;&quot;初始化随机漫步的属性&quot;&quot;&quot;</span><br><span class="line">		self.num_points = num_points</span><br><span class="line">		</span><br><span class="line">		# 所有随机漫步都始于（0，0）</span><br><span class="line">		self.x_values = [0]</span><br><span class="line">		self.y_values = [0]</span><br><span class="line">		</span><br><span class="line">	def fill_walk(self):</span><br><span class="line">		&quot;&quot;&quot;计算随机漫步包含的所有点&quot;&quot;&quot;</span><br><span class="line">		</span><br><span class="line">		# 不断漫步，直到达到指定的长度</span><br><span class="line">		while len(self.x_values) &lt; self.num_points:</span><br><span class="line">			</span><br><span class="line">			# 决定前进方向以及沿这个方向前进的距离</span><br><span class="line">			x_step = self.get_step()</span><br><span class="line">			y_step = self.get_step()</span><br><span class="line">			</span><br><span class="line">			# 拒绝原地踏步</span><br><span class="line">			if x_step == 0 and y_step == 0:</span><br><span class="line">				continue</span><br><span class="line">			</span><br><span class="line">			# 计算下一个点的 x 、y 坐标 ([-1] 指列表最后一个元素)</span><br><span class="line">			next_x = self.x_values[-1] + x_step</span><br><span class="line">			next_y = self.y_values[-1] + y_step</span><br><span class="line">			</span><br><span class="line">			self.x_values.append(next_x)</span><br><span class="line">			self.y_values.append(next_y)</span><br><span class="line">		</span><br><span class="line">	def get_step(self):</span><br><span class="line">		&quot;&quot;&quot;计算下一个点的可能前进距离&quot;&quot;&quot;</span><br><span class="line">		direction = choice([1, -1])</span><br><span class="line">		distance = choice([0, 1, 2, 3, 4])</span><br><span class="line">		step = direction * distance</span><br><span class="line">		return step</span><br></pre></td></tr></table></figure>
<h2 id="rw-visual-py"><a href="#rw-visual-py" class="headerlink" title="rw_visual.py"></a>rw_visual.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">from random_walk import RandomWalk</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">	# 创建一个RandomWalk实例，并将其包含的点都绘制出来</span><br><span class="line">	rw = RandomWalk()</span><br><span class="line">	rw.fill_walk()</span><br><span class="line">	</span><br><span class="line">	# 设置绘图窗口的尺寸</span><br><span class="line">	plt.figure(dpi=256, figsize=(10, 6))</span><br><span class="line">	</span><br><span class="line">	point_numbers = list(range(rw.num_points))</span><br><span class="line">	plt.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues, edgecolor=&apos;none&apos;, s=1)</span><br><span class="line">	</span><br><span class="line">	# 突出起点和终点</span><br><span class="line">	plt.scatter(0, 0, c=&apos;green&apos;, edgecolors=&apos;none&apos;, s=10)</span><br><span class="line">	plt.scatter(rw.x_values[-1], rw.y_values[-1], c=&apos;red&apos;, edgecolors=&apos;none&apos;, s=10)</span><br><span class="line">	</span><br><span class="line">	# 隐藏坐标轴</span><br><span class="line">	plt.axes().get_xaxis().set_visible(False)</span><br><span class="line">	plt.axes().get_yaxis().set_visible(False)</span><br><span class="line">	</span><br><span class="line">	plt.show()</span><br><span class="line"></span><br><span class="line">	keep_running = input(&quot;Make another walk? (y/n): &quot;)</span><br><span class="line">	if keep_running == &apos;n&apos;:</span><br><span class="line">		break</span><br></pre></td></tr></table></figure>
<h2 id="die-py"><a href="#die-py" class="headerlink" title="die.py"></a>die.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from random import randint</span><br><span class="line"></span><br><span class="line">class Die():</span><br><span class="line">	&quot;&quot;&quot;表示一个骰子的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, num_sides=6):</span><br><span class="line">		&quot;&quot;&quot;骰子有几面，不导入实参就默认六面&quot;&quot;&quot;</span><br><span class="line">		self.num_sides = num_sides</span><br><span class="line">		</span><br><span class="line">	def roll(self):</span><br><span class="line">		&quot;&quot;&quot;返回一个位于 1 和骰子面数之间的随机值&quot;&quot;&quot;</span><br><span class="line">		return randint(1, self.num_sides)</span><br></pre></td></tr></table></figure>
<h2 id="die-visual-py"><a href="#die-visual-py" class="headerlink" title="die_visual.py"></a>die_visual.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import pygal</span><br><span class="line"></span><br><span class="line">from die import Die</span><br><span class="line">from pylab import mpl  </span><br><span class="line">mpl.rcParams[&apos;font.sans-serif&apos;] = [&apos;SimHei&apos;]</span><br><span class="line"></span><br><span class="line"># 创建两个D6骰子</span><br><span class="line">die_1 = Die()</span><br><span class="line">die_2 = Die()</span><br><span class="line"></span><br><span class="line"># 掷几次骰子，并将结果存储在一个列表中</span><br><span class="line">results = []</span><br><span class="line">for roll_num in range(1000):</span><br><span class="line">	result = die_1.roll() + die_2.roll()</span><br><span class="line">	results.append(result)</span><br><span class="line"></span><br><span class="line"># 分析结果</span><br><span class="line">frequencies = []</span><br><span class="line">max_result = die_1.num_sides + die_2.num_sides</span><br><span class="line">for value in range(2, max_result+1):</span><br><span class="line">	frequency = results.count(value)</span><br><span class="line">	frequencies.append(frequency)</span><br><span class="line">	</span><br><span class="line"># 对结果进行可视化</span><br><span class="line">hist = pygal.Bar()</span><br><span class="line"></span><br><span class="line">hist.title = &quot;Results of rolling two D6 dice 1000 times.&quot;</span><br><span class="line">hist.x_labels = [&apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;, &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;10&apos;, &apos;11&apos;, &apos;12&apos;]</span><br><span class="line">hist.x_title = &quot;Results&quot;</span><br><span class="line">hist.y_title = &quot;Frequency of Result&quot;</span><br><span class="line"></span><br><span class="line">hist.add(&apos;D6 + D6&apos;, frequencies)</span><br><span class="line">hist.render_to_file(&apos;die_visual.svg&apos;)</span><br><span class="line"></span><br><span class="line">print(frequencies)</span><br><span class="line">print(results)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/10/14/python-引发异常-raise-及处理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/10/14/python-引发异常-raise-及处理/" itemprop="url">python 引发异常 raise() 及处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-14T16:37:31+08:00">
                2018-10-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>我们要学习异常语句处理，比如在自写函数中引入异常报警机制、用户使用程序时友好的提出异常错误等等。</p>
<blockquote>
<p>用 raise 语句来引发一个异常。异常/错误对象必须有一个名字，且它们应是 <strong>Error</strong> 或<strong> Exception </strong>类的子类。</p>
<blockquote>
<p>Python用异常对象 (exception object) 表示异常情况，遇到错误后，会引发异常。如果异常对象并未被处理或捕捉，程序就会用所谓的回溯 (Traceback,一种错误信息) 终止执行。</p>
</blockquote>
</blockquote>
<h1 id="raise-语句格式"><a href="#raise-语句格式" class="headerlink" title="raise() 语句格式"></a>raise() 语句格式</h1><p>Python 中的 raise 关键字用于引发一个异常，基本上和 Java 中的 throw 关键字相同，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def Err():</span><br><span class="line">    raise Exception(&quot;抛出一个异常&quot;) </span><br><span class="line"># Exception: 抛出一个异常 </span><br><span class="line">Err()</span><br></pre></td></tr></table></figure></p>
<p>raise 关键字后面是抛出是一个通用的异常类型 (Exception)，一般来说抛出的异常越详细越好，Python 在 exceptions 模块内建了很多的异常类型。</p>
<h1 id="传递异常"><a href="#传递异常" class="headerlink" title="传递异常"></a>传递异常</h1><p>捕捉到了异常，但是又想重新引发它(传递异常)，可以使用不带参数的raise语句即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	answer = int(first_number) / int(second_number)</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">	raise</span><br></pre></td></tr></table></figure></p>
<h1 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h1><p>Python 中也可以自定义自己的特殊类型的异常，只需要要从 Exception 类继承(直接或间接)即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class err(Exception):</span><br><span class="line">	pass</span><br></pre></td></tr></table></figure></p>
<h1 id="捕捉异常"><a href="#捕捉异常" class="headerlink" title="捕捉异常"></a>捕捉异常</h1><h2 id="捕捉一个异常"><a href="#捕捉一个异常" class="headerlink" title="捕捉一个异常"></a>捕捉一个异常</h2><p>Python 中使用 try/except 关键字来捕捉异常，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	print(5/0)</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">	print(&quot;You can&apos;t divide by 0!&quot;)</span><br></pre></td></tr></table></figure></p>
<h2 id="捕捉多个异常"><a href="#捕捉多个异常" class="headerlink" title="捕捉多个异常"></a>捕捉多个异常</h2><p>在一个 except 语句只捕捉其后声明的异常类型，如果可能会抛出的是其他类型的异常就需要再增加一个 except 语句了，或者也可以指定一个更通用的异常类型比如：Exception，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	print(5/0)</span><br><span class="line">except ZeroDivisionError:</span><br><span class="line">	print(&quot;You can&apos;t divide by 0!&quot;)</span><br><span class="line">except Exception:</span><br><span class="line">	print(&apos;其他类型异常&apos;)</span><br></pre></td></tr></table></figure></p>
<h1 id="获取异常信息"><a href="#获取异常信息" class="headerlink" title="获取异常信息"></a>获取异常信息</h1><p>有时候引发了异常，但是我们需要记录这段异常信息，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">	print(5/0)</span><br><span class="line">except (ZeroDivisionError, Exception) as err:</span><br><span class="line">	print (err)</span><br></pre></td></tr></table></figure></p>
<h1 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h1><p>finally 语句有点不同，它跟 try 语句相对独立：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(5/0)</span><br><span class="line">except (ZeroDivisionError, Exception):</span><br><span class="line">    print (&apos;发生了一个异常&apos;)</span><br><span class="line">finally:</span><br><span class="line">    print(&apos;不管是否发生异常都执行&apos;)</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/10/13/python-之装饰器解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/10/13/python-之装饰器解析/" itemprop="url">python 之装饰器解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-13T16:36:15+08:00">
                2018-10-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>装饰器很绕人，话不多说，先看代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">def outer1(func):</span><br><span class="line">	def inner(*args,**kwargs):</span><br><span class="line">		print(&quot;认证成功！&quot;)</span><br><span class="line">		result = func(*args,**kwargs)</span><br><span class="line">		print(&quot;日志添加成功&quot;)</span><br><span class="line">		return result</span><br><span class="line">	return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def outer2(func):</span><br><span class="line">	def inner(*args,**kwargs):</span><br><span class="line">		print(&quot;一条欢迎信息。。。&quot;)</span><br><span class="line">		result = func(*args,**kwargs)</span><br><span class="line">		print(&quot;一条欢送信息。。。&quot;)</span><br><span class="line">		return result</span><br><span class="line">	return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@outer1</span><br><span class="line">@outer2</span><br><span class="line">def f1(name,age):</span><br><span class="line">	print(&quot;%s 正在连接业务部门1数据接口......&quot;%name)</span><br><span class="line"></span><br><span class="line"># 调用方法</span><br><span class="line">f1(&quot;jack&quot;,18)</span><br><span class="line"></span><br><span class="line">#--------------------------------------------------</span><br><span class="line">执行结果：</span><br><span class="line"></span><br><span class="line">认证成功！</span><br><span class="line">一条欢迎信息。。。</span><br><span class="line">jack 正在连接业务部门1数据接口......</span><br><span class="line">一条欢送信息。。。</span><br><span class="line">日志添加成功</span><br></pre></td></tr></table></figure></p>
<p>看到两个 @ 了吗？<br>@ 的作用是将下面出现的函数 (f1) 作为参数传递给 @ 中的函数 (other2) ，并根据它的返回值给 f1 赋值</p>
<ol>
<li>读取 @outer1 ，此时 outer2 函数名变更为 outer1 中的 inner</li>
<li>读取 @outer2 ，此时 f1 函数名变更为 outer2 中的 inner</li>
<li>多重装饰器<strong>读取</strong>的时候自上而下，<strong>执行</strong>的时候自下而上</li>
<li>每次看到这类型的装饰器调用，比如这个，不妨先将他们等效于另一种语句，比如：<br><code>f1 = outer1(outer2(f1))(&quot;jack&quot;,18)</code> 方便理解</li>
<li>装饰器存在的目的，是为了在不改变（或者说无权改变）调用函数 f1() 的情况下，添加一些细节，比如上述的 认证成功！日志添加成功 这种</li>
<li>@ 修饰符在声明时就完成了函数名的转换</li>
</ol>
<p>此外，还有一种情况，就是装饰器带参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 认证函数</span><br><span class="line">def  auth(request,kargs):</span><br><span class="line">    print(&quot;认证成功！&quot;)</span><br><span class="line"></span><br><span class="line"># 日志函数</span><br><span class="line">def log(request,kargs):</span><br><span class="line">    print(&quot;日志添加成功&quot;)</span><br><span class="line"></span><br><span class="line"># 装饰器函数。接收两个参数，这两个参数应该是某个函数的名字。</span><br><span class="line">def Filter(auth_func,log_func):</span><br><span class="line">    # 第一层封装，f1 函数实际上被传递给了 main_fuc 这个参数</span><br><span class="line">    def outer(main_func):</span><br><span class="line">        # 第二层封装，auth 和 log 函数的参数值被传递到了这里</span><br><span class="line">        def wrapper(request,kargs):</span><br><span class="line">            # 下面代码的判断逻辑不重要，重要的是参数的引用和返回值</span><br><span class="line">            before_result = auth(request,kargs)</span><br><span class="line">            if(before_result != None):</span><br><span class="line">                return before_result;</span><br><span class="line"></span><br><span class="line">            main_result = main_func(request,kargs)</span><br><span class="line">            if(main_result != None):</span><br><span class="line">                return main_result;</span><br><span class="line"></span><br><span class="line">            after_result = log(request,kargs)</span><br><span class="line">            if(after_result != None):</span><br><span class="line">                return after_result;</span><br><span class="line"></span><br><span class="line">        return wrapper</span><br><span class="line">    return outer</span><br><span class="line"># 注意了，这里的装饰器函数有参数哦，它的意思是先执行 filter 函数</span><br><span class="line"># 然后将 filter 函数的返回值作为装饰器函数的名字返回到这里，所以，</span><br><span class="line"># 其实这里，Filter(auth,log) = outer , @Filter(auth,log) =  @outer</span><br><span class="line">@Filter(auth,log)</span><br><span class="line">def f1(name,age):</span><br><span class="line"></span><br><span class="line">    print(&quot;%s 正在连接业务部门1数据接口......&quot;%name)</span><br><span class="line"></span><br><span class="line"># 调用方法</span><br><span class="line">f1(&quot;jack&quot;,18)</span><br><span class="line"></span><br><span class="line">#-----------------------------------------------</span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">认证成功！</span><br><span class="line">jack 正在连接业务部门1数据接口......</span><br><span class="line">日志添加成功</span><br></pre></td></tr></table></figure>
<p>装饰器带参数就成了装饰器函数，这时候要先把它转换成它返回的函数：</p>
<p><code>@Filter(auth,log) =  @outer</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/10/10/小游戏之外星人入侵（第三部分）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/10/10/小游戏之外星人入侵（第三部分）/" itemprop="url">小游戏之外星人入侵（第三部分）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-10T23:14:14+08:00">
                2018-10-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><p>写在前面</p></strong></p>
<hr>
<blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<blockquote>
<p><em>游戏简介：</em><br>  <em>在游戏《外星人入侵》中，玩家控制着一艘最初出现在屏幕底部中央的飞船。玩家可以使用箭头键左右移动飞船，还可使用空格键进行射击。游戏开始时，一群外星人出现在天空中，他们在屏幕中向下移动。玩家的任务是射杀这些外星人。玩家将所有外星人都消灭干净后，将出现一群新的外星人，他们移动的速度更快。只要有外星人撞到了玩家的飞船或到达了屏幕底部，玩家就损失一艘飞船。玩家损失三艘飞船后，游戏结束。</em></p>
</blockquote>
<h1 id="项目收尾"><a href="#项目收尾" class="headerlink" title="项目收尾"></a>项目收尾</h1><p>学到这里，游戏的基本开发就已经结束了，接下来的无非就是细节的添加。<br>在这一步，我们准备添加的功能有：</p>
<ol>
<li>添加一个Play按钮，让玩家能够开始游戏</li>
<li>游戏结束后再次启动</li>
<li>消灭一群外星人后，加快游戏的节奏</li>
<li>添加一个积分系统</li>
</ol>
<h1 id="Play-按钮"><a href="#Play-按钮" class="headerlink" title="Play 按钮"></a>Play 按钮</h1><p>添加一个按钮，在游戏启动前、游戏结束后出现。<br>为此，我们在 game_stats.py 中输入如下代码：</p>
<pre><code>def __init__(self, ai_settings):
    &quot;&quot;&quot;初始化统计信息&quot;&quot;&quot;
    self.ai_settings = ai_settings
    self.reset_stats()

    # 让游戏一开始处于非活动状态
    self.game_active = False
</code></pre><p>让窗口保持非活跃状态，除非我们手动启动游戏。</p>
<h2 id="创建-Button-类"><a href="#创建-Button-类" class="headerlink" title="创建 Button 类"></a>创建 Button 类</h2><p><strong>button.py</strong></p>
<hr>
<pre><code>import pygame.font

class Button():
    def __init__(self, ai_settings, screen, msg):
        &quot;&quot;&quot;初始化按钮的属性&quot;&quot;&quot;
        self.screen = screen
        self.screen_rect = screen.get_rect()

        # 设置按钮的尺寸和其他属性
        self.width, self.height = 200, 50
        self.button_color = (0, 255, 0)
        self.text_color = (255, 255, 255)
        self.font = pygame.font.SysFont(None, 48)
        # None 表示使用默认字体，48 表示文本号

        # 创建按钮的rect对象，并使其居中
        self.rect = pygame.Rect(0, 0, self.width, self.height)
        self.rect.center = self.screen_rect.center

        # 按钮的标签只需创建一次
        self.prep_msg(msg)

    def prep_msg(self, msg):
        &quot;&quot;&quot;将msg渲染为图像，并使其在按钮上居中&quot;&quot;&quot;
        self.msg_image = self.font.render(
            msg, True, self.text_color, self.button_color)
            # 如果没有指定背景色， Pygame将以透明背景的方式渲染文本

        self.msg_image_rect = self.msg_image.get_rect()
        self.msg_image_rect.center = self.rect.center

    def draw_button(self):
        # 绘制一个用颜色填充的按钮，再绘制文本
        self.screen.fill(self.button_color, self.rect)
        self.screen.blit(self.msg_image, self.msg_image_rect)
</code></pre><p>导入模块 pygame.font，它让 Pygame 能够将文本渲染到屏幕上。msg 是要在按钮中显示的文本。prep_msg() 将你要显示的字符串渲染为图像来处理文本。<br>调用 font.render() 将存储在 msg 中的文本转换为图像，然后将该图像存储在 msg_image 中。<br>方法 font.render() 还接受一个布尔实参，该实参指定开启还是关闭反锯齿功能（反锯齿让文本的边缘更平滑）。</p>
<h2 id="在屏幕上绘制按钮"><a href="#在屏幕上绘制按钮" class="headerlink" title="在屏幕上绘制按钮"></a>在屏幕上绘制按钮</h2><p>创建了 Button 类后，在主程序中添加相关代码：</p>
<pre><code>from button import Button

def run_game():
    --snip--
    pygame.display.set_caption(&quot;Alien Invasion&quot;)

    # 创建Play按钮
    play_button = Button(ai_settings, screen, &quot;Play&quot;)
</code></pre><p>记得修改 while 循环中的参数：</p>
<p><code>gf.update_screen(ai_settings, screen, stats, ship, aliens, bullets, play_button)</code></p>
<p>接下来修改 update_screen()，以便在游戏处于非活动状态时显示 Play 按钮：</p>
<pre><code>def update_screen(ai_settings, screen, stats, ship, aliens, bullets, play_button):
    &quot;&quot;&quot;更新屏幕上的图像，并切换到新屏幕&quot;&quot;&quot;
    --snip--

    # 如果游戏处于非活动状态，就绘制Play按钮
    if not stats.game_active:
        play_button.draw_button()
</code></pre><p>此时运行，将会看到：<br><img src="/ganru.github.io/2018/10/10/小游戏之外星人入侵（第三部分）/1.png"></p>
<h2 id="响应按钮"><a href="#响应按钮" class="headerlink" title="响应按钮"></a>响应按钮</h2><p>在 game_functions 模块中的 check_events 函数添加：</p>
<pre><code>def check_events(ai_settings, screen, stats, play_button, ship, bullets):
    --snip--
    for event in pygame.event.get():
        --snip--
        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            check_play_button(stats, play_button, mouse_x, mouse_y)

def check_play_button(stats, play_button, mouse_x, mouse_y):
    &quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;
    if play_button.rect.collidepoint(mouse_x, mouse_y):
        stats.game_active = True
</code></pre><p>无论玩家单击屏幕的什么地方， Pygame 都将检测到一个 MOUSEBUTTONDOWN 事件，但我们只想让这个游戏在玩家用鼠标单击 Play 按钮时作出响应。为此，我们使用了 pygame.mouse.get_pos()，它返回一个元组，其中包含玩家单击时鼠标的x和y坐标。<br> collidepoint() 检查鼠标单击位置是否在 Play 按钮的 rect 内。</p>
<p>然后主程序修改下 <code>gf.check_events(ai_settings, screen, stats, play_button, ship, bullets)</code> 加几个形参。</p>
<h2 id="游戏重置"><a href="#游戏重置" class="headerlink" title="游戏重置"></a>游戏重置</h2><p>游戏结束后，为了让玩家再次点击按钮能够开始新一轮游戏，我们需要把所有游戏信息重置。<br>在 game_functions 中，更新 check_play_button() 的定义：</p>
<pre><code>def check_play_button(ai_settings, screen, stats,
    play_button, ship, aliens, bullets, mouse_x, mouse_y):
    &quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;
    if play_button.rect.collidepoint(mouse_x, mouse_y):
        # 重置游戏统计信息
        stats.reset_stats()

        # 清空外星人列表和子弹列表
        aliens.empty()
        bullets.empty()

        # 创建一群新的外星人，并让飞船居中
        create_fleet(ai_settings, screen, ship, aliens)
        ship.center_ship()

        stats.game_active = True
</code></pre><p>函数要导入新的形参，以便游戏的刷新。<br>改了这个函数，相对应的各个函数也得改：</p>
<pre><code>def check_events(ai_settings, screen, stats, play_button, ship, aliens, 
    bullets):
    --snip--
        check_play_button(ai_settings, screen, stats, play_button, ship,
            aliens, bullets, mouse_x, mouse_y)

主程序中的调用：
while True:
    gf.check_events(ai_settings, screen, stats, play_button, ship, aliens, bullets)
</code></pre><h2 id="BUG-修复"><a href="#BUG-修复" class="headerlink" title="BUG 修复"></a>BUG 修复</h2><p>玩的时候，发现虽然按钮消失了，但是要是继续按按钮图案所在地，游戏一样会重置。<br>为修复这个问题，可让游戏仅在 game_active 为 False 时才开始：</p>
<pre><code>def check_play_button(ai_settings, screen, stats, play_button, ship, aliens,
    bullets, mouse_x, mouse_y):
    &quot;&quot;&quot;玩家单击Play按钮时开始新游戏&quot;&quot;&quot;
    button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y)
    if button_clicked and not stats.game_active:
        #重置游戏统计信息
        --snip--
</code></pre><p>无非就是 if 语句判断条件再多加个判断值。</p>
<h1 id="隐藏光标"><a href="#隐藏光标" class="headerlink" title="隐藏光标"></a>隐藏光标</h1><p>为让玩家能够开始游戏，我们要让光标可见，但游戏开始后，光标只会添乱。为修复这种问题，我们在游戏处于活动状态时让光标不可见。</p>
<p>在上面的函数 check_play_button 中新加一段：</p>
<pre><code>def check_play_button(ai_settings, screen, stats, play_button, ship, aliens,
    bullets, mouse_x, mouse_y):
    &quot;&quot;&quot;玩家单击Play按钮时开始新游戏&quot;&quot;&quot;
    button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y)
    if button_clicked and not stats.game_active:
        # 隐藏光标
        pygame.mouse.set_visible(False)
        --snip--
</code></pre><p>通过向 set_visible() 传递 False，让 Pygame 在光标位于游戏窗口内时将其隐藏起来。<br>但是游戏结束后，我们要让光标重新出现：</p>
<pre><code>def ship_hit(ai_settings, screen, stats, ship, aliens, bullets):
    &quot;&quot;&quot;响应飞船被外星人撞到&quot;&quot;&quot;
    if stats.ships_left &gt; 0:
        --snip--
    else:
        stats.game_active = False
        pygame.mouse.set_visible(True)    # 新增
</code></pre><h1 id="游戏难度"><a href="#游戏难度" class="headerlink" title="游戏难度"></a>游戏难度</h1><p>我们可以设定：打完这群外星人后，加快游戏节奏。</p>
<h2 id="速度设置"><a href="#速度设置" class="headerlink" title="速度设置"></a>速度设置</h2><p>在文件 settings.py 中添加：</p>
<pre><code>def __init__(self):
    --snip--
    # 以什么样的速度加快游戏节奏
    self.speedup_scale = 1.1
    self.initialize_dynamic_settings()

def initialize_dynamic_settings(self):
    &quot;&quot;&quot;初始化随游戏进行而变化的设置&quot;&quot;&quot;
    self.ship_speed_factor = 1.5
    self.bullet_speed_factor = 3
    self.alien_speed_factor = 1

    # fleet_direction为1表示向右；为-1表示向左
    self.fleet_direction = 1

def increase_speed(self):
    &quot;&quot;&quot;提高速度设置&quot;&quot;&quot;
    self.ship_speed_factor *= self.speedup_scale
    self.bullet_speed_factor *= self.speedup_scale
    self.alien_speed_factor *= self.speedup_scale
</code></pre><p>然后修改 game_functions 中的 check_bullet_alien_collisions() 函数：</p>
<pre><code>def check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets):
    &quot;&quot;&quot;响应子弹和外星人的碰撞&quot;&quot;&quot;
    --snip--

    if len(aliens) == 0:
        # 删除现有的所有子弹，并创建一个新的外星人群，游戏节奏加速
        bullets.empty()
        ai_settings.increase_speed()    # 新增
        create_fleet(ai_settings, screen, ship, aliens)
</code></pre><h2 id="速度重置"><a href="#速度重置" class="headerlink" title="速度重置"></a>速度重置</h2><p>每次启动新游戏的时候，速度也要重置。<br><strong>game_functions.py</strong></p>
<pre><code>def check_play_button(ai_settings, screen, stats, play_button, ship, aliens,
    bullets, mouse_x, mouse_y):
    &quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;
    button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y)
    if button_clicked and not stats.game_active:
        # 重置游戏设置
        ai_settings.initialize_dynamic_settings()    # 新增

        # 隐藏光标
        pygame.mouse.set_visible(False)
        --snip--
</code></pre><h1 id="计分模式"><a href="#计分模式" class="headerlink" title="计分模式"></a>计分模式</h1><p>我们在 game_stats 中的 reset_stats() 加入一段：</p>
<p><code>self.score = 0</code></p>
<p>为在每次开始游戏时都重置得分，我们在 reset_stats() 而不是 __init__() 中初始化 score。</p>
<p>为在屏幕上显示得分，我们首先创建一个新类 Scoreboard 。</p>
<p><strong>scoreboard.py</strong></p>
<hr>
<pre><code>import pygame.font

class Scoreboard():
    &quot;&quot;&quot;显示得分信息的类&quot;&quot;&quot;

    def __init__(self, ai_settings, screen, stats):
        &quot;&quot;&quot;初始化显示得分涉及的属性&quot;&quot;&quot;
        self.screen = screen
        self.screen_rect = screen.get_rect()
        self.ai_settings = ai_settings
        self.stats = stats

        # 显示得分信息时使用的字体设置
        self.text_color = (30, 30, 30)
        self.font = pygame.font.SysFont(None, 48)

        # 准备初始得分图像
        self.prep_score()

    def prep_score(self):
        &quot;&quot;&quot;将得分转换为一幅渲染的图像&quot;&quot;&quot;
        score_str = str(self.stats.score)
        self.score_image = self.font.render(score_str, True, self.text_color,
            self.ai_settings.bg_color)

        # 将得分放在屏幕右上角
        self.score_rect = self.score_image.get_rect()
        self.score_rect.right = self.screen_rect.right - 20
        self.score_rect.top = 20

    def show_score(self):
        &quot;&quot;&quot;在屏幕上显示得分&quot;&quot;&quot;
        self.screen.blit(self.score_image, self.score_rect)
</code></pre><p>因为要在屏幕上显示文本，所以我们导入 pygame.font 。<br>然后，修改 game_functions 的函数 update_screen:</p>
<pre><code>def update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets,
    play_button):
    # 显示得分
    sb.show_score()
    --snip--
</code></pre><p>然后，在主程序中写入：</p>
<pre><code>from scoreboard import Scoreboard

def run_game():
    --snip--
    # 创建存储游戏统计信息的实例，并创建记分牌
    stats = GameStats(ai_settings)
    sb = Scoreboard(ai_settings, screen, stats)
    --snip--
    # 开始游戏主循环
    while True:
        gf.update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets,
            play_button)    # 加个形参
</code></pre><p>结果如下：<br><img src="/ganru.github.io/2018/10/10/小游戏之外星人入侵（第三部分）/2.jpg"></p>
<h1 id="实时更新得分"><a href="#实时更新得分" class="headerlink" title="实时更新得分"></a>实时更新得分</h1><p>我们令击杀一个外星人得到的分为 50 。<br><strong>settings.py</strong></p>
<pre><code>def initialize_dynamic_settings(self):
    --snip--
    # 记分
    self.alien_points = 50
</code></pre><p><strong>game_functions.py</strong></p>
<pre><code>def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, 
    aliens, bullets):
    collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)

    if collisions:
        stats.score += ai_settings.alien_points
        sb.prep_score()        # 实时更新得分图像
</code></pre><p>新增形参 stats 和 sb 。<br>修改之后由于新增形参的关系，update_bullets() 函数也受到了影响。</p>
<pre><code>def update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets):
    &quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;
    --snip--

    check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship,
        aliens, bullets)
</code></pre><p>修改主程序实时更新函数：</p>
<p><code>gf.update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets)</code></p>
<p>写到这里，做了个测试，发现大子弹打中多个敌人时加的分只有 50 ，这个我们需要考虑。<br>前面我们创建了一个实例 collisions ，它接收因子弹与外星人碰撞得到的结果而形成的字典。在 check_bullet_alien_collisions() 中，与外星人碰撞的子弹都是字典 collisions 中的一个键；而与每颗子弹相关的值都是一个列表，其中包含该子弹撞到的外星人。<br>每击杀一个外星人，字典都会新增一个 value 。所以我们可以遍历该字典。</p>
<pre><code>def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, 
    aliens, bullets):
    &quot;&quot;&quot;响应子弹和外星人的碰撞&quot;&quot;&quot;
    # 删除发生碰撞的子弹和外星人
    collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)

    if collisions:
        for aliens in collisions.values():
            stats.score += ai_settings.alien_points * len(aliens)
            sb.prep_score()
</code></pre><h1 id="提高点数"><a href="#提高点数" class="headerlink" title="提高点数"></a>提高点数</h1><p>游戏越难，点数应该越高，不然没什么意思。</p>
<pre><code>class Settings():
    &quot;&quot;&quot;存储游戏《外星人入侵》的所有设置的类&quot;&quot;&quot;

    def __init__(self):
        --snip--
        # 加快游戏节奏的速度
        self.speedup_scale = 1.1
        # 外星人点数的提高速度
        self.score_scale = 1.5    # 新增

        self.initialize_dynamic_settings()

    def increase_speed(self):
        &quot;&quot;&quot;提高速度设置和外星人点数&quot;&quot;&quot;
        self.ship_speed_factor *= self.speedup_scale
        self.bullet_speed_factor *= self.speedup_scale
        self.alien_speed_factor *= self.speedup_scale

        self.alien_points = int(self.alien_points * self.score_scale)    # 新增
        print(self.alien_points)
</code></pre><p>为检验效果，我们可以加一条语句 <code>print(self.alien_points)</code> 看看在终端他的速度变化。不过记得删掉。</p>
<h1 id="将得分圆整"><a href="#将得分圆整" class="headerlink" title="将得分圆整"></a>将得分圆整</h1><p>将得分显示为 10 的整数倍。<br>我们修改一下 scoreboard:</p>
<pre><code>def prep_score(self):
    &quot;&quot;&quot;将得分转换为一幅渲染的图像&quot;&quot;&quot;
    rounded_score = int(round(self.stats.score, -1))
    score_str = &quot;{:,}&quot;.format(rounded_score)
    self.score_image = self.font.render(score_str, True, self.text_color,
        self.ai_settings.bg_color)

    --snip--
</code></pre><p>函数 round() 通常让小数精确到小数点后多少位，其中小数位数是由第二个实参指定的。如果将第二个实参指定为负数， round() 将圆整到最近的 10、100、1000 等整数倍。<br>“{:,}” 是字符串格式设置指令，它让 Python 将数值转换为字符串时在其中插入逗号，例如，输出 1,000,000 而不是 1000000。</p>
<h1 id="最高得分"><a href="#最高得分" class="headerlink" title="最高得分"></a>最高得分</h1><p>注意，任何情况下都不会重置它。所以，我们将它放在 __init__() 中。<br><strong>game_stats.py</strong></p>
<pre><code>def __init__(self, ai_settings):
    --snip--
    # 在任何情况下都不应重置最高得分
    self.high_score = 0
</code></pre><p>然后我们要显示这个图像：<br><strong>scoreboard.py</strong></p>
<pre><code>def __init__(self, ai_settings, screen, stats):
    --snip--
    # 准备包含最高得分和当前得分的图像
    self.prep_score()
    self.prep_high_score()

def prep_high_score(self):
    &quot;&quot;&quot;将最高得分转换为渲染的图像&quot;&quot;&quot;
    high_score = int(round(self.stats.high_score, -1))
    high_score_str = &quot;{:,}&quot;.format(high_score)
    self.high_score_image = self.font.render(high_score_str, True,
        self.text_color, self.ai_settings.bg_color)

    # 将最高得分放在屏幕顶部中央
    self.high_score_rect = self.high_score_image.get_rect()
    self.high_score_rect.centerx = self.screen_rect.centerx
    self.high_score_rect.top = self.score_rect.top    # 保持和得分图像 y 高度一致
</code></pre><p>显示最高得分：</p>
<pre><code>def show_score(self):
    &quot;&quot;&quot;在屏幕上显示得分和最高得分&quot;&quot;&quot;
    self.screen.blit(self.score_image, self.score_rect)
    self.screen.blit(self.high_score_image, self.high_score_rect)
</code></pre><p>我们还要加个检测机制，判断是否有最高得分出现：<br><strong>game_functions.py</strong></p>
<pre><code>def check_high_score(stats, sb):
    &quot;&quot;&quot;检查是否诞生了新的最高得分&quot;&quot;&quot;
    if stats.score &gt; stats.high_score:
        stats.high_score = stats.score
        sb.prep_high_score()

def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, 
    aliens, bullets):
    --snip--

    if collisions:
        for aliens in collisions.values():
            stats.score += ai_settings.alien_points * len(aliens)
            sb.prep_score()
        check_high_score(stats, sb)        # 新增
</code></pre><h1 id="显示当前难度等级"><a href="#显示当前难度等级" class="headerlink" title="显示当前难度等级"></a>显示当前难度等级</h1><p>为确保每次开始新游戏时都重置等级，在 reset_stats() 中初始化它：<br><strong>game_stats.py</strong></p>
<pre><code>def reset_stats(self):
    &quot;&quot;&quot;初始化随游戏进行可能变化的统计信息&quot;&quot;&quot;
    self.ships_left = self.ai_settings.ship_limit
    self.score = 0
    self.level = 1
</code></pre><p>显示等级：<br><strong>scoreboard.py</strong></p>
<pre><code>def __init__(self, ai_settings, screen, stats):
    --snip--

    # 准备包含得分的初始图像
    self.prep_score()
    self.prep_high_score()
    self.prep_level()

def prep_level(self):
    &quot;&quot;&quot;将等级转换为渲染的图像&quot;&quot;&quot;
    self.level_image = self.font.render(str(self.stats.level), True,
        self.text_color, self.ai_settings.bg_color)

    # 将等级放在得分下方
    self.level_rect = self.level_image.get_rect()
    self.level_rect.right = self.score_rect.right
    self.level_rect.top = self.score_rect.bottom + 10

def show_score(self):
    &quot;&quot;&quot;在屏幕上显示飞船和得分&quot;&quot;&quot;
    self.screen.blit(self.score_image, self.score_rect)
    self.screen.blit(self.high_score_image, self.high_score_rect)
    self.screen.blit(self.level_image, self.level_rect)
</code></pre><p>结果如下：<br><img src="/ganru.github.io/2018/10/10/小游戏之外星人入侵（第三部分）/3.jpg"></p>
<h1 id="等级更新"><a href="#等级更新" class="headerlink" title="等级更新"></a>等级更新</h1><p>打完一波后，升级。<br><strong>game_functions.py</strong></p>
<pre><code>def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship,
    aliens, bullets):
    --snip--
    if len(aliens) == 0:
        # 如果整群外星人都被消灭，就提高一个等级
        bullets.empty()
        ai_settings.increase_speed()

        # 提高等级
        stats.level += 1
        sb.prep_level()
</code></pre><h1 id="开始新游戏时重置积分与等级"><a href="#开始新游戏时重置积分与等级" class="headerlink" title="开始新游戏时重置积分与等级"></a>开始新游戏时重置积分与等级</h1><p><strong>game_functions.py</strong></p>
<pre><code>def check_play_button(ai_settings, screen, stats, sb, play_button, ship,
    aliens, bullets, mouse_x, mouse_y):

    # 重置游戏统计信息
    stats.reset_stats()
    stats.game_active = True

    # 重置记分牌图像
    sb.prep_score()
    sb.prep_high_score()
    sb.prep_level()
</code></pre><p>新增形参 sb ，新增的代码要在重置游戏统计信息之前。<br>更新会调用到它的函数：</p>
<pre><code>def check_events(ai_settings, screen, stats, sb, play_button, ship, aliens,
    bullets):
    --snip--

        elif event.type == pygame.MOUSEBUTTONDOWN:
            mouse_x, mouse_y = pygame.mouse.get_pos()
            check_play_button(ai_settings, screen, stats, sb, 
                play_button, ship, aliens, bullets, mouse_x, mouse_y)
</code></pre><p>更新主程序：</p>
<pre><code>while True:
    gf.check_events(ai_settings, screen, stats, sb, play_button, ship, aliens, bullets)
</code></pre><h1 id="剩余生命值"><a href="#剩余生命值" class="headerlink" title="剩余生命值"></a>剩余生命值</h1><p>使用图形而不是数字。<br>让 ship 继承 Sprite 类。<br><strong>ship.py</strong></p>
<pre><code>from pygame.sprite import Sprite

class Ship(Sprite):

    def __init__(self, ai_settings, screen):
        &quot;&quot;&quot;初始化飞船，并设置其起始位置&quot;&quot;&quot;
        super(Ship, self).__init__()
        --snip--
</code></pre><p>修改 Scoreboard ，在其中创建一个可供显示的飞船编组。<br><strong>scoreboard.py</strong></p>
<pre><code>from pygame.sprite import Group

from ship import Ship

    --snip--
    def __init__(self, ai_settings, screen, stats):
        --snip--
        self.prep_level()
        self.prep_ships()    # 新增
        --snip--

    def prep_ships(self):
        &quot;&quot;&quot;显示还余下多少艘飞船&quot;&quot;&quot;
        self.ships = Group()
        for ship_number in range(self.stats.ships_left):
            # 飞船数目列表化生成 {1, 2, 3}（相当于从 1 数到 3 ）
            ship = Ship(self.ai_settings, self.screen)
            ship.rect.x = 10 + ship_number * ship.rect.width
            ship.rect.y = 10
            self.ships.add(ship)

    def show_score(self):
        &quot;&quot;&quot;在屏幕上显示飞船和得分&quot;&quot;&quot;
        self.screen.blit(self.score_image, self.score_rect)
        self.screen.blit(self.high_score_image, self.high_score_rect)
        self.screen.blit(self.level_image, self.level_rect)

        # 绘制飞船
        self.ships.draw(self.screen)
</code></pre><p>跳转到 game_functions 中的 check_play_button：</p>
<pre><code># 重置记分牌图像
    sb.prep_score()
    sb.prep_high_score()
    sb.prep_level()
    sb.prep_ships()        # 新增
</code></pre><p>在游戏开始时显示飞船生命。</p>
<p>此外，如果玩家飞船撞毁，更新飞船剩余生命：<br><strong>game_functions.py</strong></p>
<pre><code>def update_aliens(ai_settings, stats, `sb`, screen, ship, aliens, bullets):
    &quot;&quot;&quot;检查是否有外星人位于屏幕边缘，并更新整群外星人的位置&quot;&quot;&quot;
    check_fleet_edges(ai_settings, aliens)
    aliens.update()

    # 检测外星人和飞船之间的碰撞
    if pygame.sprite.spritecollideany(ship, aliens):
        ship_hit(ai_settings, stats, `sb`, screen, ship, aliens, bullets)

    # 检查是否有外星人到达屏幕底端
    check_aliens_bottom(ai_settings, stats, `sb`, screen, ship, aliens, bullets)

def check_aliens_bottom(ai_settings, stats, `sb`, screen, ship, aliens, bullets):
    &quot;&quot;&quot;检查是否有外星人到达了屏幕底端&quot;&quot;&quot;
    screen_rect = screen.get_rect()
    for alien in aliens.sprites():
        if alien.rect.bottom &gt;= screen_rect.bottom:
            # 像飞船被撞到一样进行处理
            ship_hit(ai_settings, stats, `sb`, screen, ship, aliens, bullets)
            break

def ship_hit(ai_settings, stats, `sb`, screen, ship, aliens, bullets):
    &quot;&quot;&quot;响应被外星人撞到的飞船&quot;&quot;&quot;
    if stats.ships_left &gt; 0:
        # 将 ships_left 减 1
        stats.ships_left -= 1

        # 更新记分牌
        sb.prep_ships()        # 新增
</code></pre><p>变化在于新增了行代码 <code>sb.prep_ships()</code>，不过有几个函数受 ship_hit 影响，故贴出其他函数。<br>主函数也受到了影响：</p>
<p><code>gf.update_aliens(ai_settings, stats, sb, screen, ship, aliens, bullets)</code></p>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><ol>
<li>如何创建用于开始新游戏的Play按钮</li>
<li>如何检测鼠标事件</li>
<li>如何显示\隐藏光标</li>
<li>如何随游戏的进行调整其节奏</li>
<li>如何实现记分系统</li>
<li>如何以文本和非文本方式显示信息</li>
</ol>
<h1 id="此部分各组件源码"><a href="#此部分各组件源码" class="headerlink" title="此部分各组件源码"></a>此部分各组件源码</h1><h2 id="alien-invasion-py"><a href="#alien-invasion-py" class="headerlink" title="alien_invasion.py"></a>alien_invasion.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line">from pygame.sprite import Group</span><br><span class="line"></span><br><span class="line">from settings import Settings</span><br><span class="line">from game_stats import GameStats</span><br><span class="line">from scoreboard import Scoreboard</span><br><span class="line">from button import Button</span><br><span class="line">from ship import Ship</span><br><span class="line">import game_functions as gf</span><br><span class="line"></span><br><span class="line">def run_game():</span><br><span class="line">	# 初始化游戏并创建一个屏幕对象</span><br><span class="line">	pygame.init()</span><br><span class="line">	ai_settings = Settings()</span><br><span class="line">	screen = pygame.display.set_mode(</span><br><span class="line">		(ai_settings.screen_width, ai_settings.screen_height))</span><br><span class="line">	pygame.display.set_caption(&quot;Alien Invasion&quot;)	#窗口名称</span><br><span class="line">	</span><br><span class="line">	# 创建存储游戏统计信息的实例，并创建记分牌</span><br><span class="line">	stats = GameStats(ai_settings)</span><br><span class="line">	sb = Scoreboard(ai_settings, screen, stats)</span><br><span class="line">	</span><br><span class="line">	# 创建飞船</span><br><span class="line">	ship = Ship(ai_settings, screen)</span><br><span class="line">	</span><br><span class="line">	# 创建一个用于存储子弹的编组</span><br><span class="line">	bullets = Group()</span><br><span class="line">	</span><br><span class="line">	# 创建外星人编组</span><br><span class="line">	aliens = Group()</span><br><span class="line">	</span><br><span class="line">	# 创建外星人群</span><br><span class="line">	gf.create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line">	</span><br><span class="line">	# 创建Play按钮</span><br><span class="line">	play_button = Button(ai_settings, screen, &quot;Play&quot;)</span><br><span class="line">	</span><br><span class="line">	# 开始游戏的主循环</span><br><span class="line">	while True:</span><br><span class="line">		gf.check_events(ai_settings, screen, stats, sb, play_button, ship, aliens, bullets)</span><br><span class="line">		</span><br><span class="line">		if stats.game_active:</span><br><span class="line">			ship.update()	# 飞船的位置将在检测到键盘事件后（但在更新屏幕前）更新</span><br><span class="line">			gf.update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets)</span><br><span class="line">			gf.update_aliens(ai_settings, stats, sb, screen, ship, aliens, bullets)</span><br><span class="line">		</span><br><span class="line">		gf.update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets, play_button)</span><br><span class="line"></span><br><span class="line">run_game()</span><br></pre></td></tr></table></figure>
<h2 id="game-functions-py"><a href="#game-functions-py" class="headerlink" title="game_functions.py"></a>game_functions.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">import pygame</span><br><span class="line"></span><br><span class="line">from bullet import Bullet</span><br><span class="line">from alien import Alien</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def check_keydown_events(event, ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应按键&quot;&quot;&quot;</span><br><span class="line">	if event.key == pygame.K_RIGHT:</span><br><span class="line">		ship.moving_right = True</span><br><span class="line">	elif event.key == pygame.K_LEFT:</span><br><span class="line">		ship.moving_left = True</span><br><span class="line">	elif event.key == pygame.K_SPACE:</span><br><span class="line">		fire_bullet(ai_settings, screen, ship, bullets)</span><br><span class="line">	elif event.key == pygame.K_q:</span><br><span class="line">		sys.exit()</span><br><span class="line"></span><br><span class="line">def check_keyup_events(event, ship):</span><br><span class="line">	&quot;&quot;&quot;响应松开&quot;&quot;&quot;</span><br><span class="line">	if event.key == pygame.K_RIGHT:</span><br><span class="line">		ship.moving_right = False</span><br><span class="line">	elif event.key == pygame.K_LEFT:</span><br><span class="line">		ship.moving_left = False</span><br><span class="line"></span><br><span class="line">def check_events(ai_settings, screen, stats, sb, play_button, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;</span><br><span class="line">	for event in pygame.event.get():</span><br><span class="line">		if event.type == pygame.QUIT:</span><br><span class="line">			sys.exit()</span><br><span class="line">			</span><br><span class="line">		elif event.type == pygame.KEYDOWN:</span><br><span class="line">			check_keydown_events(event, ai_settings, screen, ship, bullets)</span><br><span class="line">		elif event.type == pygame.KEYUP:</span><br><span class="line">			check_keyup_events(event, ship)</span><br><span class="line">		</span><br><span class="line">		elif event.type == pygame.MOUSEBUTTONDOWN:</span><br><span class="line">			mouse_x, mouse_y = pygame.mouse.get_pos()</span><br><span class="line">			check_play_button(ai_settings, screen, stats, sb, </span><br><span class="line">				play_button, ship, aliens, bullets, mouse_x, mouse_y)</span><br><span class="line"></span><br><span class="line">def check_play_button(ai_settings, screen, stats, sb, </span><br><span class="line">	play_button, ship, aliens, bullets, mouse_x, mouse_y):</span><br><span class="line">	&quot;&quot;&quot;在玩家单击Play按钮时开始新游戏&quot;&quot;&quot;</span><br><span class="line">	button_clicked = play_button.rect.collidepoint(mouse_x, mouse_y)</span><br><span class="line">	if button_clicked and not stats.game_active:</span><br><span class="line">		</span><br><span class="line">		# 重置游戏统计信息</span><br><span class="line">		stats.reset_stats()</span><br><span class="line">		stats.game_active = True</span><br><span class="line">		</span><br><span class="line">		# 重置记分牌图像</span><br><span class="line">		sb.prep_score()</span><br><span class="line">		sb.prep_high_score()</span><br><span class="line">		sb.prep_level()</span><br><span class="line">		sb.prep_ships()</span><br><span class="line">		</span><br><span class="line">		# 清空外星人列表和子弹列表</span><br><span class="line">		aliens.empty()</span><br><span class="line">		bullets.empty()</span><br><span class="line">		</span><br><span class="line">		# 重置游戏设置</span><br><span class="line">		ai_settings.initialize_dynamic_settings()</span><br><span class="line"></span><br><span class="line">		# 隐藏光标</span><br><span class="line">		pygame.mouse.set_visible(False)</span><br><span class="line">		</span><br><span class="line">		# 创建一群新的外星人，并让飞船居中</span><br><span class="line">		create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line">		ship.center_ship()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def update_screen(ai_settings, screen, stats, sb, ship, aliens, bullets,</span><br><span class="line">		play_button):</span><br><span class="line">	&quot;&quot;&quot;更新屏幕上的图像，并切换到新屏幕&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	# 每次循环时都重绘屏幕</span><br><span class="line">	screen.fill(ai_settings.bg_color)</span><br><span class="line">	# 重绘所有子弹</span><br><span class="line">	for bullet in bullets.sprites():</span><br><span class="line">		bullet.draw_bullet()</span><br><span class="line">	ship.blitme()</span><br><span class="line">	aliens.draw(screen)	# 括号记得导入窗口参数</span><br><span class="line">	</span><br><span class="line">	# 显示得分</span><br><span class="line">	sb.show_score()</span><br><span class="line">	</span><br><span class="line">	# 如果游戏处于非活动状态，就绘制Play按钮</span><br><span class="line">	if not stats.game_active:</span><br><span class="line">		play_button.draw_button()</span><br><span class="line">	</span><br><span class="line">	# 让最近绘制的屏幕可见</span><br><span class="line">	pygame.display.flip()</span><br><span class="line"></span><br><span class="line">def update_bullets(ai_settings, screen, stats, sb, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;</span><br><span class="line">	# 更新子弹的位置</span><br><span class="line">	bullets.update()	# 这步看不懂的话注意一下模块 game_functions.check_keydown_events() 函数</span><br><span class="line">	</span><br><span class="line">	# 删除已消失的子弹</span><br><span class="line">	for bullet in bullets.copy():</span><br><span class="line">		if bullet.rect.bottom &lt;= 0:</span><br><span class="line">			bullets.remove(bullet)</span><br><span class="line">	</span><br><span class="line">	# 响应子弹与外星人的碰撞</span><br><span class="line">	check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, </span><br><span class="line">		aliens, bullets)</span><br><span class="line"></span><br><span class="line">def check_bullet_alien_collisions(ai_settings, screen, stats, sb, ship, </span><br><span class="line">		aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应子弹和外星人的碰撞&quot;&quot;&quot;</span><br><span class="line">	# 删除发生碰撞的子弹和外星人</span><br><span class="line">	collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)</span><br><span class="line">	</span><br><span class="line">	if collisions:</span><br><span class="line">		for aliens in collisions.values():</span><br><span class="line">			stats.score += ai_settings.alien_points * len(aliens)</span><br><span class="line">			sb.prep_score()</span><br><span class="line">		check_high_score(stats, sb)</span><br><span class="line">	</span><br><span class="line">	if len(aliens) == 0:</span><br><span class="line">		# 删除现有的所有子弹，并创建一个新的外星人群，游戏节奏加速</span><br><span class="line">		bullets.empty()</span><br><span class="line">		ai_settings.increase_speed()</span><br><span class="line">		</span><br><span class="line">		# 提高等级</span><br><span class="line">		stats.level += 1</span><br><span class="line">		sb.prep_level()</span><br><span class="line">		</span><br><span class="line">		create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line"></span><br><span class="line">def fire_bullet(ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;如果还没有到达限制，就发射一颗子弹&quot;&quot;&quot;</span><br><span class="line">	#创建新子弹，并将其加入到编组bullets中</span><br><span class="line">	if len(bullets) &lt; ai_settings.bullets_allowed:</span><br><span class="line">		new_bullet = Bullet(ai_settings, screen, ship)</span><br><span class="line">		bullets.add(new_bullet)</span><br><span class="line"></span><br><span class="line">def get_number_aliens_x(ai_settings, alien_width):</span><br><span class="line">	&quot;&quot;&quot;计算每行可容纳多少个外星人&quot;&quot;&quot;</span><br><span class="line">	available_space_x = ai_settings.screen_width - 2 * alien_width</span><br><span class="line">	number_aliens_x = int(available_space_x / (2 * alien_width))</span><br><span class="line">	return number_aliens_x</span><br><span class="line"></span><br><span class="line">def get_number_rows(ai_settings, ship_height, alien_height):</span><br><span class="line">	&quot;&quot;&quot;计算屏幕可容纳多少行外星人&quot;&quot;&quot;</span><br><span class="line">	available_space_y = (ai_settings.screen_height - </span><br><span class="line">		(3 * alien_height) - ship_height)</span><br><span class="line">	number_rows = int(available_space_y / (2 * alien_height))</span><br><span class="line">	return number_rows</span><br><span class="line"></span><br><span class="line">def create_alien(ai_settings, screen, aliens, alien_number, row_number):</span><br><span class="line">	&quot;&quot;&quot;创建一个外星人并将其放在当前行&quot;&quot;&quot;</span><br><span class="line">	alien = Alien(ai_settings, screen)</span><br><span class="line">	alien_width = alien.rect.width</span><br><span class="line">	</span><br><span class="line">	# 不要两句并一句，因为在 Alien 类中，我们设定了 alien.x 可以保存小数值</span><br><span class="line">	alien.x = alien_width + 2 * alien_width * alien_number</span><br><span class="line">	alien.rect.x = alien.x</span><br><span class="line">	</span><br><span class="line">	alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number</span><br><span class="line">	aliens.add(alien)</span><br><span class="line"></span><br><span class="line">def create_fleet(ai_settings, screen, ship, aliens):</span><br><span class="line">	&quot;&quot;&quot;创建外星人群&quot;&quot;&quot;</span><br><span class="line">	# 创建一个外星人，并计算一行可容纳多少个外星人</span><br><span class="line">	# 外星人间距为外星人宽度</span><br><span class="line">	alien = Alien(ai_settings, screen)</span><br><span class="line">	number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)</span><br><span class="line">	number_rows = get_number_rows(</span><br><span class="line">		ai_settings, ship.rect.height, alien.rect.height)</span><br><span class="line">	# 创建第一行外星人</span><br><span class="line">	</span><br><span class="line">	for row_number in range(number_rows):</span><br><span class="line">		for alien_number in range(number_aliens_x):</span><br><span class="line">			# 创建一个外星人并将其加入当前行</span><br><span class="line">			create_alien(ai_settings, screen, aliens, alien_number, row_number)</span><br><span class="line">	</span><br><span class="line">def check_fleet_edges(ai_settings, aliens):</span><br><span class="line">	&quot;&quot;&quot;有外星人到达边缘时采取相应的措施&quot;&quot;&quot;</span><br><span class="line">	for alien in aliens.sprites():</span><br><span class="line">		if alien.check_edges():</span><br><span class="line">			change_fleet_direction(ai_settings, aliens)</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">def change_fleet_direction(ai_settings, aliens):</span><br><span class="line">	&quot;&quot;&quot;将整群外星人下移，并改变它们的方向&quot;&quot;&quot;</span><br><span class="line">	for alien in aliens.sprites():</span><br><span class="line">		alien.rect.y += ai_settings.fleet_drop_speed</span><br><span class="line">	ai_settings.fleet_direction *= -1</span><br><span class="line">	</span><br><span class="line">def update_aliens(ai_settings, stats, sb, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;检查是否有外星人位于屏幕边缘，并更新整群外星人的位置&quot;&quot;&quot;</span><br><span class="line">	check_fleet_edges(ai_settings, aliens)</span><br><span class="line">	aliens.update()</span><br><span class="line">	</span><br><span class="line">	# 检测外星人和飞船之间的碰撞</span><br><span class="line">	if pygame.sprite.spritecollideany(ship, aliens):</span><br><span class="line">		ship_hit(ai_settings, stats, sb, screen, ship, aliens, bullets)</span><br><span class="line">	</span><br><span class="line">	# 检查是否有外星人到达屏幕底端</span><br><span class="line">	check_aliens_bottom(ai_settings, stats, sb, screen, ship, aliens, bullets)</span><br><span class="line"></span><br><span class="line">def check_aliens_bottom(ai_settings, stats, sb, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;检查是否有外星人到达了屏幕底端&quot;&quot;&quot;</span><br><span class="line">	screen_rect = screen.get_rect()</span><br><span class="line">	for alien in aliens.sprites():</span><br><span class="line">		if alien.rect.bottom &gt;= screen_rect.bottom:</span><br><span class="line">			# 像飞船被撞到一样进行处理</span><br><span class="line">			ship_hit(ai_settings, stats, sb, screen, ship, aliens, bullets)</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">def ship_hit(ai_settings, stats, sb, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应被外星人撞到的飞船&quot;&quot;&quot;</span><br><span class="line">	if stats.ships_left &gt; 0:</span><br><span class="line">		# 将 ships_left 减 1</span><br><span class="line">		stats.ships_left -= 1</span><br><span class="line">		</span><br><span class="line">		# 更新记分牌</span><br><span class="line">		sb.prep_ships()</span><br><span class="line">		</span><br><span class="line">		# 清空外星人列表和子弹列表</span><br><span class="line">		aliens.empty()</span><br><span class="line">		bullets.empty()</span><br><span class="line">		</span><br><span class="line">		# 创建一群新的外星人，并将飞船放到屏幕底端中央</span><br><span class="line">		create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line">		ship.center_ship()</span><br><span class="line">		</span><br><span class="line">		# 暂停</span><br><span class="line">		sleep(0.5)</span><br><span class="line">	</span><br><span class="line">	else:</span><br><span class="line">		stats.game_active = False</span><br><span class="line">		pygame.mouse.set_visible(True)</span><br><span class="line">		</span><br><span class="line">def check_high_score(stats, sb):</span><br><span class="line">	&quot;&quot;&quot;检查是否诞生了新的最高得分&quot;&quot;&quot;</span><br><span class="line">	if stats.score &gt; stats.high_score:</span><br><span class="line">		stats.high_score = stats.score</span><br><span class="line">		sb.prep_high_score()</span><br></pre></td></tr></table></figure>
<h2 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">class Settings():</span><br><span class="line">	&quot;&quot;&quot;存储《外星人入侵》的所有设置的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self):</span><br><span class="line">		&quot;&quot;&quot;初始化游戏的静态设置&quot;&quot;&quot;</span><br><span class="line">		# 屏幕设置</span><br><span class="line">		self.screen_width = 1200</span><br><span class="line">		self.screen_height = 800</span><br><span class="line">		self.bg_color = (230, 230, 230)</span><br><span class="line">		</span><br><span class="line">		# 飞船的设置</span><br><span class="line">		self.ship_speed_factor = 1.5</span><br><span class="line">		self.ship_limit = 3</span><br><span class="line">		</span><br><span class="line">		# 子弹设置</span><br><span class="line">		self.bullet_speed_factor = 3</span><br><span class="line">		self.bullet_width = 3</span><br><span class="line">		self.bullet_height = 15</span><br><span class="line">		self.bullet_color = 60, 60, 60</span><br><span class="line">		self.bullets_allowed = 3</span><br><span class="line">		</span><br><span class="line">		# 外星人设置</span><br><span class="line">		self.alien_speed_factor = 1</span><br><span class="line">		self.fleet_drop_speed = 10</span><br><span class="line">		# fleet_direction 为 1 表示向右移，为 - 1 表示向左移</span><br><span class="line">		self.fleet_direction = 1</span><br><span class="line">		</span><br><span class="line">		# 以什么样的速度加快游戏节奏</span><br><span class="line">		self.speedup_scale = 1.1</span><br><span class="line">		self.initialize_dynamic_settings()</span><br><span class="line">		</span><br><span class="line">		# 外星人点数的提高速度</span><br><span class="line">		self.score_scale = 1.5</span><br><span class="line">		</span><br><span class="line">	def initialize_dynamic_settings(self):</span><br><span class="line">		&quot;&quot;&quot;初始化随游戏进行而变化的设置&quot;&quot;&quot;</span><br><span class="line">		self.ship_speed_factor = 1.5</span><br><span class="line">		self.bullet_speed_factor = 3</span><br><span class="line">		self.alien_speed_factor = 1</span><br><span class="line">		</span><br><span class="line">		# fleet_direction为 1 表示向右；为 -1 表示向左</span><br><span class="line">		self.fleet_direction = 1</span><br><span class="line">		</span><br><span class="line">		# 记分</span><br><span class="line">		self.alien_points = 50</span><br><span class="line">	</span><br><span class="line">	def increase_speed(self):</span><br><span class="line">		&quot;&quot;&quot;提高速度设置与外星人点数&quot;&quot;&quot;</span><br><span class="line">		self.ship_speed_factor *= self.speedup_scale</span><br><span class="line">		self.bullet_speed_factor *= self.speedup_scale</span><br><span class="line">		self.alien_speed_factor *= self.speedup_scale</span><br><span class="line">		</span><br><span class="line">		self.alien_points = int(self.alien_points * self.score_scale)</span><br></pre></td></tr></table></figure>
<h2 id="ship-py"><a href="#ship-py" class="headerlink" title="ship.py"></a>ship.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line">from pygame.sprite import Sprite</span><br><span class="line"></span><br><span class="line">class Ship(Sprite):</span><br><span class="line"></span><br><span class="line">	def __init__(self, ai_settings, screen):</span><br><span class="line">		&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br><span class="line">		super(Ship, self).__init__()</span><br><span class="line">		self.screen = screen</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		</span><br><span class="line">		# 加载飞船图像并获取其外接矩形</span><br><span class="line">		self.image = pygame.image.load(&apos;images/ship.bmp&apos;)</span><br><span class="line">		self.rect = self.image.get_rect()</span><br><span class="line">		self.screen_rect = screen.get_rect()</span><br><span class="line">		</span><br><span class="line">		# 将每艘新飞船放在屏幕底部中央</span><br><span class="line">		self.rect.centerx = self.screen_rect.centerx</span><br><span class="line">		self.rect.bottom = self.screen_rect.bottom</span><br><span class="line">		</span><br><span class="line">		# 在飞船的属性center中存储小数值</span><br><span class="line">		self.center = float(self.rect.centerx)</span><br><span class="line">		</span><br><span class="line">		# 移动标志</span><br><span class="line">		self.moving_right = False</span><br><span class="line">		self.moving_left = False</span><br><span class="line">		</span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br><span class="line">		# 更新飞船的 center 值，而不是 rect</span><br><span class="line">		if self.moving_right and self.rect.right &lt; self.screen_rect.right:</span><br><span class="line">		# self.rect.right 是飞船图案的右边坐标</span><br><span class="line">			self.center += self.ai_settings.ship_speed_factor</span><br><span class="line">		if self.moving_left and self.rect.left &gt; 0:</span><br><span class="line">			self.center -= self.ai_settings.ship_speed_factor</span><br><span class="line">			</span><br><span class="line">		# 根据self.center更新rect对象</span><br><span class="line">		self.rect.centerx = self.center</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	def blitme(self):</span><br><span class="line">		&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span><br><span class="line">		self.screen.blit(self.image, self.rect)</span><br><span class="line"></span><br><span class="line">	def center_ship(self):</span><br><span class="line">		&quot;&quot;&quot;让飞船在屏幕上居中&quot;&quot;&quot;</span><br><span class="line">		self.center = self.screen_rect.centerx</span><br></pre></td></tr></table></figure>
<h2 id="bullet-py"><a href="#bullet-py" class="headerlink" title="bullet.py"></a>bullet.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line">from pygame.sprite import Sprite</span><br><span class="line"></span><br><span class="line">class Bullet(Sprite):</span><br><span class="line">	&quot;&quot;&quot;一个对飞船发射的子弹进行管理的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, ai_settings, screen, ship):</span><br><span class="line">		&quot;&quot;&quot;在飞船所处的位置创建一个子弹对象&quot;&quot;&quot;</span><br><span class="line">		super().__init__()</span><br><span class="line">		self.screen = screen</span><br><span class="line">		</span><br><span class="line">		# 在(0,0)处创建一个表示子弹的矩形，再设置正确的位置</span><br><span class="line">		self.rect = pygame.Rect(0, 0, ai_settings.bullet_width, ai_settings.bullet_height)</span><br><span class="line">		self.rect.centerx = ship.rect.centerx</span><br><span class="line">		self.rect.top = ship.rect.top</span><br><span class="line">		</span><br><span class="line">		#存储用小数表示的子弹位置</span><br><span class="line">		self.y = float(self.rect.y)</span><br><span class="line">		self.color = ai_settings.bullet_color</span><br><span class="line">		self.speed_factor = ai_settings.bullet_speed_factor</span><br><span class="line">	</span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;</span><br><span class="line">		#更新表示子弹位置的小数值</span><br><span class="line">		self.y -= self.speed_factor</span><br><span class="line">		#更新表示子弹的rect的位置</span><br><span class="line">		self.rect.y = self.y</span><br><span class="line">		</span><br><span class="line">	def draw_bullet(self):</span><br><span class="line">		&quot;&quot;&quot;在屏幕上绘制子弹&quot;&quot;&quot;</span><br><span class="line">		pygame.draw.rect(self.screen, self.color, self.rect)</span><br></pre></td></tr></table></figure>
<h2 id="alien-py"><a href="#alien-py" class="headerlink" title="alien.py"></a>alien.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line"></span><br><span class="line">from pygame.sprite import Sprite</span><br><span class="line"></span><br><span class="line">class Alien(Sprite):</span><br><span class="line">	&quot;&quot;&quot;表示单个外星人的类&quot;&quot;&quot;</span><br><span class="line">	def __init__(self, ai_settings, screen):</span><br><span class="line">		&quot;&quot;&quot;初始化外星人并设置其起始位置&quot;&quot;&quot;</span><br><span class="line">		super().__init__()</span><br><span class="line">		self.screen = screen</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		</span><br><span class="line">		# 加载外星人的图像并矩形化</span><br><span class="line">		self.image = pygame.image.load(&apos;images/alien.bmp&apos;)</span><br><span class="line">		self.rect = self.image.get_rect()</span><br><span class="line">		</span><br><span class="line">		# 设置外星人的左边距、上边距</span><br><span class="line">		#（其实就是令外星人图像左上角的坐标点该位于何方）</span><br><span class="line">		self.rect.x = self.rect.width</span><br><span class="line">		self.rect.y = self.rect.height</span><br><span class="line">		</span><br><span class="line">		# 存储外星人的准确位置</span><br><span class="line">		self.x = float(self.rect.x)</span><br><span class="line">	</span><br><span class="line">	def blitme(self):</span><br><span class="line">		&quot;&quot;&quot;在指定位置绘制外星人&quot;&quot;&quot;</span><br><span class="line">		self.screen.blit(self.image, self.rect)</span><br><span class="line"></span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;左右移动外星人&quot;&quot;&quot;</span><br><span class="line">		self.x += (self.ai_settings.alien_speed_factor * self.ai_settings.fleet_direction)</span><br><span class="line">		self.rect.x = self.x</span><br><span class="line">	</span><br><span class="line">	def check_edges(self):</span><br><span class="line">		&quot;&quot;&quot;如果外星人位于屏幕边缘，就返回True&quot;&quot;&quot;</span><br><span class="line">		screen_rect = self.screen.get_rect()</span><br><span class="line">		if self.rect.right &gt;= screen_rect.right:</span><br><span class="line">			return True</span><br><span class="line">		elif self.rect.left &lt;= 0:</span><br><span class="line">			return True</span><br></pre></td></tr></table></figure>
<h2 id="game-stats-py"><a href="#game-stats-py" class="headerlink" title="game_stats.py"></a>game_stats.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class GameStats():</span><br><span class="line">	&quot;&quot;&quot;跟踪游戏的统计信息&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, ai_settings):</span><br><span class="line">		&quot;&quot;&quot;初始化统计信息&quot;&quot;&quot;</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		self.reset_stats()</span><br><span class="line">		</span><br><span class="line">		# 在任何情况下都不应重置最高得分</span><br><span class="line">		self.high_score = 0</span><br><span class="line">		</span><br><span class="line">		# 游戏刚启动时处于非活动状态</span><br><span class="line">		self.game_active = False</span><br><span class="line">	</span><br><span class="line">	def reset_stats(self):</span><br><span class="line">		&quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot;</span><br><span class="line">		self.ships_left = self.ai_settings.ship_limit</span><br><span class="line">		self.score = 0</span><br><span class="line">		self.level = 1</span><br></pre></td></tr></table></figure>
<h2 id="button-py"><a href="#button-py" class="headerlink" title="button.py"></a>button.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import pygame.font</span><br><span class="line"></span><br><span class="line">class Button():</span><br><span class="line">	def __init__(self, ai_settings, screen, msg):</span><br><span class="line">		&quot;&quot;&quot;初始化按钮的属性&quot;&quot;&quot;</span><br><span class="line">		self.screen = screen</span><br><span class="line">		self.screen_rect = screen.get_rect()</span><br><span class="line">	</span><br><span class="line">		# 设置按钮的尺寸和其他属性</span><br><span class="line">		self.width, self.height = 200, 50</span><br><span class="line">		self.button_color = (0, 255, 0)</span><br><span class="line">		self.text_color = (255, 255, 255)</span><br><span class="line">		self.font = pygame.font.SysFont(None, 48)</span><br><span class="line">		</span><br><span class="line">		# 创建按钮的rect对象，并使其居中</span><br><span class="line">		self.rect = pygame.Rect(0, 0, self.width, self.height)</span><br><span class="line">		self.rect.center = self.screen_rect.center</span><br><span class="line">		</span><br><span class="line">		# 按钮的标签只需创建一次</span><br><span class="line">		self.prep_msg(msg)</span><br><span class="line">	</span><br><span class="line">	def prep_msg(self, msg):</span><br><span class="line">		&quot;&quot;&quot;将msg渲染为图像，并使其在按钮上居中&quot;&quot;&quot;</span><br><span class="line">		self.msg_image = self.font.render(</span><br><span class="line">			msg, True, self.text_color, self.button_color)</span><br><span class="line">			# 如果没有指定背景色， Pygame将以透明背景的方式渲染文本</span><br><span class="line">		</span><br><span class="line">		self.msg_image_rect = self.msg_image.get_rect()</span><br><span class="line">		self.msg_image_rect.center = self.rect.center</span><br><span class="line">	</span><br><span class="line">	def draw_button(self):</span><br><span class="line">		# 绘制一个用颜色填充的按钮，再绘制文本</span><br><span class="line">		self.screen.fill(self.button_color, self.rect)</span><br><span class="line">		self.screen.blit(self.msg_image, self.msg_image_rect)</span><br></pre></td></tr></table></figure>
<h2 id="scoreboard-py"><a href="#scoreboard-py" class="headerlink" title="scoreboard.py"></a>scoreboard.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">import pygame.font</span><br><span class="line">from pygame.sprite import Group</span><br><span class="line"></span><br><span class="line">from ship import Ship</span><br><span class="line"></span><br><span class="line">class Scoreboard():</span><br><span class="line">	&quot;&quot;&quot;显示得分信息的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, ai_settings, screen, stats):</span><br><span class="line">		&quot;&quot;&quot;初始化显示得分涉及的属性&quot;&quot;&quot;</span><br><span class="line">		self.screen = screen</span><br><span class="line">		self.screen_rect = screen.get_rect()</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		self.stats = stats</span><br><span class="line">		</span><br><span class="line">		# 显示得分信息时使用的字体设置</span><br><span class="line">		self.text_color = (30, 30, 30)</span><br><span class="line">		self.font = pygame.font.SysFont(None, 48)</span><br><span class="line">		</span><br><span class="line">		# 准备包含最高得分和当前得分的图像</span><br><span class="line">		self.prep_score()</span><br><span class="line">		self.prep_high_score()</span><br><span class="line">		self.prep_level()</span><br><span class="line">		self.prep_ships()</span><br><span class="line">		</span><br><span class="line">	def prep_score(self):</span><br><span class="line">		&quot;&quot;&quot;将得分转换为一幅渲染的图像&quot;&quot;&quot;</span><br><span class="line">		rounded_score = int(round(self.stats.score, -1))</span><br><span class="line">		score_str = &quot;&#123;:,&#125;&quot;.format(rounded_score)</span><br><span class="line">		self.score_image = self.font.render(score_str, True, self.text_color,</span><br><span class="line">			self.ai_settings.bg_color)</span><br><span class="line">		</span><br><span class="line">		# 将得分放在屏幕右上角</span><br><span class="line">		self.score_rect = self.score_image.get_rect()</span><br><span class="line">		self.score_rect.right = self.screen_rect.right - 20</span><br><span class="line">		self.score_rect.top = 20</span><br><span class="line">		</span><br><span class="line">	def prep_high_score(self):</span><br><span class="line">		&quot;&quot;&quot;将最高得分转换为渲染的图像&quot;&quot;&quot;</span><br><span class="line">		high_score = int(round(self.stats.high_score, -1))</span><br><span class="line">		high_score_str = &quot;&#123;:,&#125;&quot;.format(high_score)</span><br><span class="line">		self.high_score_image = self.font.render(high_score_str, True,</span><br><span class="line">			self.text_color, self.ai_settings.bg_color)</span><br><span class="line"></span><br><span class="line">		#将最高得分放在屏幕顶部中央</span><br><span class="line">		self.high_score_rect = self.high_score_image.get_rect()</span><br><span class="line">		self.high_score_rect.centerx = self.screen_rect.centerx</span><br><span class="line">		self.high_score_rect.top = self.score_rect.top</span><br><span class="line">		</span><br><span class="line">	def prep_level(self):</span><br><span class="line">		&quot;&quot;&quot;将等级转换为渲染的图像&quot;&quot;&quot;</span><br><span class="line">		self.level_image = self.font.render(str(self.stats.level), True,</span><br><span class="line">			self.text_color, self.ai_settings.bg_color)</span><br><span class="line">		</span><br><span class="line">		# 将等级放在得分下方</span><br><span class="line">		self.level_rect = self.level_image.get_rect()</span><br><span class="line">		self.level_rect.right = self.score_rect.right</span><br><span class="line">		self.level_rect.top = self.score_rect.bottom + 10</span><br><span class="line">	</span><br><span class="line">	def prep_ships(self):</span><br><span class="line">		&quot;&quot;&quot;显示还余下多少艘飞船&quot;&quot;&quot;</span><br><span class="line">		self.ships = Group()</span><br><span class="line">		for ship_number in range(self.stats.ships_left):</span><br><span class="line">			ship = Ship(self.ai_settings, self.screen)</span><br><span class="line">			ship.rect.x = 10 + ship_number * ship.rect.width</span><br><span class="line">			ship.rect.y = 10</span><br><span class="line">			self.ships.add(ship)</span><br><span class="line">	</span><br><span class="line">	def show_score(self):</span><br><span class="line">		&quot;&quot;&quot;在屏幕上显示飞船和得分&quot;&quot;&quot;</span><br><span class="line">		self.screen.blit(self.score_image, self.score_rect)</span><br><span class="line">		self.screen.blit(self.high_score_image, self.high_score_rect)</span><br><span class="line">		self.screen.blit(self.level_image, self.level_rect)</span><br><span class="line">		</span><br><span class="line">		# 绘制飞船</span><br><span class="line">		self.ships.draw(self.screen)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/10/07/小游戏之外星人入侵（第二部分）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/10/07/小游戏之外星人入侵（第二部分）/" itemprop="url">小游戏之外星人入侵（第二部分）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-07T18:28:47+08:00">
                2018-10-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><p>写在前面</p></strong></p>
<hr>
<blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<blockquote>
<p><em>游戏简介：</em><br>  <em>在游戏《外星人入侵》中，玩家控制着一艘最初出现在屏幕底部中央的飞船。玩家可以使用箭头键左右移动飞船，还可使用空格键进行射击。游戏开始时，一群外星人出现在天空中，他们在屏幕中向下移动。玩家的任务是射杀这些外星人。玩家将所有外星人都消灭干净后，将出现一群新的外星人，他们移动的速度更快。只要有外星人撞到了玩家的飞船或到达了屏幕底部，玩家就损失一艘飞船。玩家损失三艘飞船后，游戏结束。</em></p>
</blockquote>
<h1 id="项目回顾"><a href="#项目回顾" class="headerlink" title="项目回顾"></a>项目回顾</h1><p>先别急着上手第二部分开发，回顾下之前的既有代码以及制定开发计划。<br>开发步骤：</p>
<ol>
<li>研究既有代码，确定实现新功能前是否要进行重构。</li>
<li>在屏幕左上角添加一个外星人，并指定合适的边距。</li>
<li>根据第一个外星人的边距和屏幕尺寸计算屏幕上可容纳多少个外星人。我们将编写一个循环来创建一系列外星人，这些外星人填满了屏幕的上半部分。</li>
<li>让外星人群向两边和下方移动，直到外星人被全部击落，有外星人撞到飞船，或有外星人抵达屏幕底端。如果整群外星人都被击落，我们将再创建一群外星人。如果有外星人撞到了飞船或抵达屏幕底端，我们将销毁飞船并再创建一群外星人。</li>
<li>限制玩家可用的飞船数量，配给的飞船用完后，游戏结束。</li>
</ol>
<h1 id="创建外星人"><a href="#创建外星人" class="headerlink" title="创建外星人"></a>创建外星人</h1><h2 id="设置快捷键快速退出游戏（可选）"><a href="#设置快捷键快速退出游戏（可选）" class="headerlink" title="设置快捷键快速退出游戏（可选）"></a>设置快捷键快速退出游戏（可选）</h2><p>有点不想每次测试完都点一点鼠标退出游戏，加个按键 Q 让它快速退出。</p>
<pre><code>def check_keydown_events(event, ai_settings, screen, ship, bullets):
    --snip--
    elif event.key == pygame.K_q:
        sys.exit()
</code></pre><h2 id="创建第一个外星人"><a href="#创建第一个外星人" class="headerlink" title="创建第一个外星人"></a>创建第一个外星人</h2><p>我们新建一个模块 Alien 类，方便管理外星人：<br><strong>Alien.py</strong></p>
<hr>
<pre><code>import pygame
from pygame.sprite import Sprite

class Alien(Sprite):
    &quot;&quot;&quot;表示单个外星人的类&quot;&quot;&quot;
    def __init__(self, ai_settings, screen):
        &quot;&quot;&quot;初始化外星人并设置其起始位置&quot;&quot;&quot;
        super().__init__()
        self.screen = screen
        self.ai_settings = ai_settings

        # 加载外星人的图像并矩形化
        self.image = pygame.image.load(&apos;images/alien.bmp&apos;)
        self.rect = self.image.get_rect()

        # 设置外星人的左边距、上边距
        self.rect.x = self.rect.width
        self.rect.y = self.rect.height

        # 存储外星人的准确位置
        self.x = float(self.rect.x)

    def blitme(self):
        &quot;&quot;&quot;在指定位置绘制外星人&quot;&quot;&quot;
        self.screen.blit(self.image, self.rect)
</code></pre><p>然后就是在主程序中创建外星人实例：<br>记得导入模块 Alien 。</p>
<pre><code>from alien import Alien

def run_game():
    --snip--
    # 创建一个外星人
    alien = Alien(ai_settings, screen)

    # 开始游戏主循环
    while True:
    ...
    gf.update_screen(ai_settings, screen, ship, alien, bullets)    #这行先加进去
</code></pre><p>然后在 game_functions.py 中修改：</p>
<pre><code>def update_screen(ai_settings, screen, ship, alien, bullets):
    --snip--
    # 在飞船和外星人后面重绘所有的子弹
    for bullet in bullets:
    bullet.draw_bullet()
    ship.blitme()
    alien.blitme()    # 这是新增加的
</code></pre><p>最后试试运行游戏，如果像这样：<br><img src="/ganru.github.io/2018/10/07/小游戏之外星人入侵（第二部分）/1.png"><br>那就成功了，接下来就可以试试建一群外星人。</p>
<h2 id="创建一群外星人"><a href="#创建一群外星人" class="headerlink" title="创建一群外星人"></a>创建一群外星人</h2><p>我们预判一下一行坐标可用空间有多少，因为我们设定两边都有外星人宽度的空白地带，所以：</p>
<p><code>available_space_x = ai_settings.screen_width – (2 * alien_width)</code></p>
<p>可容纳空间弄出来了，接下来看看能放几个外星人：</p>
<p><code>number_aliens_x = available_space_x / (2 * alien_width)</code>（每两个外星人隔一个外星人间距）</p>
<p>公式导出来了，接下来就是写写写了。</p>
<p>主程序中加入一个 alien 编组，存放外星人。</p>
<p><code>aliens = Group()</code></p>
<p>记得删掉之前在主程序的建立外星人的相关代码，我们接下来要建一群。<br>不过在此之前我们得更新下 game_functions 的代码，让外星人群能够显示：</p>
<pre><code>def update_screen(ai_settings, screen, ship, aliens, bullets):
    --snip--
    ship.blitme()
    aliens.draw(screen)    # 括号记得导入窗口参数
</code></pre><p>然后返回主程序新建：</p>
<pre><code># 创建外星人群
gf.create_fleet(ai_settings, screen, aliens)
</code></pre><p>主循环中修改代码：<code>gf.update_screen(ai_settings, screen, ship, aliens, bullets)</code></p>
<p>然后对函数模块新建一个函数：<br>记得导入 alien.py 。</p>
<pre><code>from alien import Alien

def create_fleet(ai_settings, screen, aliens):
    &quot;&quot;&quot;创建外星人群&quot;&quot;&quot;
    # 创建一个外星人，并计算一行可容纳多少个外星人
    # 外星人间距为外星人宽度
    alien = Alien(ai_settings, screen)
    alien_width = alien.rect.width    # 获取宽度，以免之后的代码反复访问 rect 属性
    available_space_x = ai_settings.screen_width - 2 * alien_width
    number_aliens_x = int(available_space_x / (2 * alien_width))    # 记得变为整型，我们建立的是浮点坐标

    # 创建第一行外星人
    for alien_number in range(number_aliens_x):
        # 创建一个外星人并将其加入当前行
        alien = Alien(ai_settings, screen)

        # 不要两句并一句，因为在 Alien 类中，我们设定了 alien.x 可以保存小数值
        alien.x = alien_width + 2 * alien_width * alien_number
        alien.rect.x = alien.x

        aliens.add(alien)
</code></pre><p>这时候运行结果是这样：<br><img src="/ganru.github.io/2018/10/07/小游戏之外星人入侵（第二部分）/2.png"></p>
<h2 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h2><p>函数 create_fleet(ai_settings, screen, aliens) 有点繁杂，重构一下：<br>新建两个函数：</p>
<pre><code>def get_number_aliens_x(ai_settings, alien_width):
    &quot;&quot;&quot;计算每行可容纳多少个外星人&quot;&quot;&quot;
    available_space_x = ai_settings.screen_width - 2 * alien_width
    number_aliens_x = int(available_space_x / (2 * alien_width))
    return number_aliens_x

def create_alien(ai_settings, screen, aliens, alien_number):
    &quot;&quot;&quot;创建一个外星人并将其放在当前行&quot;&quot;&quot;
    alien = Alien(ai_settings, screen)
    alien_width = alien.rect.width

    # 不要两句并一句，因为在 Alien 类中，我们设定了 alien.x 可以保存小数值
    alien.x = alien_width + 2 * alien_width * alien_number
    alien.rect.x = alien.x

    aliens.add(alien)
</code></pre><p>原先的函数修改一下：</p>
<pre><code>def create_fleet(ai_settings, screen, aliens):
    &quot;&quot;&quot;创建外星人群&quot;&quot;&quot;
    # 创建一个外星人，并计算一行可容纳多少个外星人
    # 外星人间距为外星人宽度
    alien = Alien(ai_settings, screen)
    number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)
    # 创建第一行外星人

    for alien_number in range(number_aliens_x):
        # 创建一个外星人并将其加入当前行
        create_alien(ai_settings, screen, aliens, alien_number)
</code></pre><h2 id="复建外星人行"><a href="#复建外星人行" class="headerlink" title="复建外星人行"></a>复建外星人行</h2><p>为计算可容纳的行数，我们这样计算可用垂直空间：将屏幕高度减去第一行外星人的上边距（外星人高度）、飞船的高度以及最初外星人群与飞船的距离（外星人高度的两倍）：</p>
<p><code>available_space_y = ai_settings.screen_height – 3 * alien_height – ship_height</code></p>
<p>每行下方都要留出一定的空白区域，并将其设置为外星人的高度。为计算可容纳的行数，我们将可用垂直空间除以外星人高度的两倍（同样，如果这样的计算不对，我们马上就能发现，继而将间距调整为合理的值）。</p>
<p><code>number_rows = available_height_y / (2 * alien_height)</code></p>
<p>知道可容纳多少行后，便可重复执行创建一行外星人的代码：</p>
<pre><code>def get_number_rows(ai_settings, ship_height, alien_height):
    &quot;&quot;&quot;计算屏幕可容纳多少行外星人&quot;&quot;&quot;
    available_space_y = (ai_settings.screen_height - 
        (3 * alien_height) - ship_height)
    number_rows = int(available_space_y / (2 * alien_height))
    return number_rows

def create_alien(ai_settings, screen, aliens, alien_number, row_number):
    --snip--
    alien.rect.x = alien.x
    alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number
    aliens.add(alien)

def create_fleet(ai_settings, screen, ship, aliens):
    --snip--
    number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)
    number_rows = get_number_rows(ai_settings, ship.rect.height,
        alien.rect.height)

    for row_number in range(number_rows):
        for alien_number in range(number_aliens_x):
            # 创建一个外星人并将其加入当前行
            create_alien(ai_settings, screen, aliens, alien_number, row_number)
</code></pre><p>这时候转回主程序修改：</p>
<p><code>gf.create_fleet(ai_settings, screen, ship, aliens)</code></p>
<p>加多个 ship 形参。</p>
<p>如果想好玩点，可以像这样操作：</p>
<pre><code>from random import randint
random_number = randint(-10,10)
</code></pre><p>让外星人随机分布。</p>
<h2 id="让外星人群移动"><a href="#让外星人群移动" class="headerlink" title="让外星人群移动"></a>让外星人群移动</h2><h3 id="右移外星人"><a href="#右移外星人" class="headerlink" title="右移外星人"></a>右移外星人</h3><p>要让外星人移动，得添加个外星人速度设置：<br>在 settings.py 中添加：</p>
<pre><code>def __init__(self):
    --snip--
    # 外星人设置
    self.alien_speed_factor = 1
</code></pre><p>然后，在模块 alien.py 中添加：</p>
<pre><code>def update(self):
    &quot;&quot;&quot;向右移动外星人&quot;&quot;&quot;
    self.x += self.ai_settings.alien_speed_factor
    self.rect.x = self.x
</code></pre><p>写完后，在主程序 while 循环中加入刷新代码：</p>
<p><code>gf.update_aliens(aliens)</code></p>
<p>要加载到子弹更新之后，因为我们待会还要加入子弹与外星人碰撞检定功能。<br>最后，更新位置（在 <strong>game_functions.py*</strong> 添加）：</p>
<pre><code>def update_aliens(aliens):
    &quot;&quot;&quot;更新外星人群中所有外星人的位置&quot;&quot;&quot;
    aliens.update()
</code></pre><h3 id="创建表示外星人移动方向的设置"><a href="#创建表示外星人移动方向的设置" class="headerlink" title="创建表示外星人移动方向的设置"></a>创建表示外星人移动方向的设置</h3><p>在 settings.py 中添加：</p>
<pre><code># 外星人设置
self.alien_speed_factor = 1
self.fleet_drop_speed = 10
# fleet_direction为1表示向右移，为-1表示向左移
self.fleet_direction = 1
</code></pre><p>设置 fleet_drop_speed 指定了有外星人撞到屏幕边缘时，外星人群向下移动的速度。<br>要实现fleet_direction设置，可以将其设置为文本值，如’left’或’right’，但这样就必须编写 if-elif 语句来检查外星人群的移动方向。鉴于只有两个可能的方向，我们使用值 1 和 -1 来表示它们，并在外星人群改变方向时在这两个值之间切换。另外，鉴于向右移动时需要增大每个外星人的 x 坐标，而向左移动时需要减小每个外星人的 x 坐标，使用数字来表示方向更合理。</p>
<h3 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>如果外星人撞到左右屏幕：<br>我们在 alien.py 中添加：</p>
<pre><code>def check_edges(self):
    &quot;&quot;&quot;如果外星人位于屏幕边缘，就返回True&quot;&quot;&quot;
    screen_rect = self.screen.get_rect()
    if self.rect.right &gt;= screen_rect.right:
        return True
    elif self.rect.left &lt;= 0:
        return True
</code></pre><p>修改：</p>
<pre><code>def update(self):
    &quot;&quot;&quot;向左或向右移动外星人&quot;&quot;&quot;
    self.x += (self.ai_settings.alien_speed_factor * self.ai_settings.fleet_direction)
    self.rect.x = self.x
</code></pre><h3 id="向下移动外星人群"><a href="#向下移动外星人群" class="headerlink" title="向下移动外星人群"></a>向下移动外星人群</h3><p>这时候要做的动静可能比较大，我们在模块 game_functions.py 中添加：</p>
<pre><code>def check_fleet_edges(ai_settings, aliens):
    &quot;&quot;&quot;有外星人到达边缘时采取相应的措施&quot;&quot;&quot;
    for alien in aliens.sprites():
        if alien.check_edges():
            change_fleet_direction(ai_settings, aliens)
            break

def change_fleet_direction(ai_settings, aliens):
    &quot;&quot;&quot;将整群外星人下移，并改变它们的方向&quot;&quot;&quot;
    for alien in aliens.sprites():
        alien.rect.y += ai_settings.fleet_drop_speed
    ai_settings.fleet_direction *= -1

def update_aliens(ai_settings, aliens):
    &quot;&quot;&quot;检查是否有外星人位于屏幕边缘，并更新整群外星人的位置&quot;&quot;&quot;
    check_fleet_edges(ai_settings, aliens)
    aliens.update()
</code></pre><h2 id="射杀外星人"><a href="#射杀外星人" class="headerlink" title="射杀外星人"></a>射杀外星人</h2><p>方法 sprite.groupcollide() 将每颗子弹的 rect 同每个外星人的 rect 进行比较，并返回一个字典，其中包含发生了碰撞的子弹和外星人。<br>在 bullet.py 模块中，加入代码检测碰撞：</p>
<pre><code>def update_bullets(aliens, bullets):
    &quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;
    --snip--
    # 检查是否有子弹击中了外星人
    # 如果是这样，就删除相应的子弹和外星人
    collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)
</code></pre><p>两个 True 告诉 Pygame 删除发生碰撞的子弹和外星人。<br>（要模拟能够穿行到屏幕顶端的高能子弹——消灭它击中的每个外星人，可将第一个布尔实参设置为 False，并让第二个布尔实参为 True。这样被击中的外星人将消失，但所有的子弹都始终有效，直到抵达屏幕顶端后消失。）<br>这时候运行射击结果是这样：<br><img src="/ganru.github.io/2018/10/07/小游戏之外星人入侵（第二部分）/3.jpg"></p>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><p>我们最后要试试能不能杀掉全部外星人，那么不太可能一个一个干掉，太繁琐，我们可以做个大子弹：<br>将 settings.py 中的 <code>self.bullet_width = 300</code>，看看能不能消灭。<br>当然，别忘了改回来。</p>
<h2 id="复建一群外星人"><a href="#复建一群外星人" class="headerlink" title="复建一群外星人"></a>复建一群外星人</h2><p>打完后，不可能游戏就结束，我们在做一群。<br>首先，检查下外星人库 aliens 是否为空。<br>我们在模块 game_functions 中的 update_bullets 中添加：</p>
<pre><code>if len(aliens) == 0:
    # 删除现有的子弹并新建一群外星人
    bullets.empty()
    create_fleet(ai_settings, screen, ship, aliens)
</code></pre><h2 id="代码重构-1"><a href="#代码重构-1" class="headerlink" title="代码重构"></a>代码重构</h2><p>做到这一步，有没有感觉 game_functions 里的代码有点杂？<br>我们重构一下 update_bullets ，这里加了太多东西了。</p>
<pre><code>def update_bullets(ai_settings, screen, ship, aliens, bullets):
    &quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;
    # 更新子弹的位置
    bullets.update()    # 这步看不懂的话注意一下模块 game_functions.check_keydown_events() 函数

    # 删除已消失的子弹
    for bullet in bullets.copy():
        if bullet.rect.bottom &lt;= 0:
            bullets.remove(bullet)

    # 响应子弹与外星人的碰撞
    check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets)
</code></pre><p>然后再建一个函数：</p>
<pre><code>def check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets):
    &quot;&quot;&quot;响应子弹和外星人的碰撞&quot;&quot;&quot;
    # 删除发生碰撞的子弹和外星人
    collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)

    if len(aliens) == 0:
        # 删除现有的所有子弹，并创建一个新的外星人群
        bullets.empty()
        create_fleet(ai_settings, screen, ship, aliens)
</code></pre><h2 id="游戏结束"><a href="#游戏结束" class="headerlink" title="游戏结束"></a>游戏结束</h2><h3 id="碰撞检测-1"><a href="#碰撞检测-1" class="headerlink" title="碰撞检测"></a>碰撞检测</h3><p>外星人碰到飞船怎么办？那就游戏结束了。<br>方法 spritecollideany() 接受两个实参：一个精灵和一个编组。它检查编组是否有成员与精灵发生了碰撞，并在找到与精灵发生了碰撞的成员后就停止遍历编组。<br>在这里，它遍历编组 aliens，并返回它找到的第一个与飞船发生了碰撞的外星人。</p>
<pre><code>game_functions.py
* * *
def update_aliens(ai_settings, ship, aliens):
    &quot;&quot;&quot;检查是否有外星人位于屏幕边缘，并更新整群外星人的位置&quot;&quot;&quot;
    check_fleet_edges(ai_settings, aliens)
    aliens.update()

    # 检测外星人和飞船之间的碰撞
    if pygame.sprite.spritecollideany(ship, aliens):
        print(&quot;Ship hit!!!&quot;)
</code></pre><p>如果没有发生碰撞， spritecollideany() 将返回 None，因此 if 代码块不会执行。如果找到了与飞船发生碰撞的外星人，它就返回这个外星人，因此if代码块将执行：打印“Ship hit!!!”<br>我们运行试试：<br><img src="/ganru.github.io/2018/10/07/小游戏之外星人入侵（第二部分）/4.jpg"></p>
<h3 id="响应飞船与外星人的碰撞"><a href="#响应飞船与外星人的碰撞" class="headerlink" title="响应飞船与外星人的碰撞"></a>响应飞船与外星人的碰撞</h3><p>上面的 <code>print(&quot;Ship hit!!!&quot;)</code> 可以删了，现在我们做一个新的类：</p>
<p><strong>game_stats.py</strong></p>
<hr>
<pre><code>class GameStats():
    &quot;&quot;&quot;跟踪游戏的统计信息&quot;&quot;&quot;

    def __init__(self, ai_settings):
        &quot;&quot;&quot;初始化统计信息&quot;&quot;&quot;
        self.ai_settings = ai_settings
        self.reset_stats()

    def reset_stats(self):
        &quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot;
        self.ships_left = self.ai_settings.ship_limit
</code></pre><p>这个类有助于我们统计游戏进度，还方便统计后面要做的计分模式。<br>目前我们只统计飞船的生命，在 settings 中添加：</p>
<p><code>self.ship_limit = 3</code></p>
<p>然后对主程序修改导包：</p>
<pre><code>from game_stats import GameStats

def run_game():
    --snip--
    # 创建一个用于存储游戏统计信息的实例
    stats = GameStats(ai_settings)

    while True:
        gf.update_aliens(ai_settings, stats, screen, ship, aliens, bullets)
</code></pre><p>有外星人撞到飞船时，我们将余下的飞船数减 1，创建一群新的外星人，并将飞船重新放置到屏幕底端中央（我们还将让游戏暂停一段时间，让玩家在新外星人群出现前注意到发生了碰撞，并将重新创建外星人群）。</p>
<p>在 game_functions 新建 ship_hit() 函数：<br>先导入包：</p>
<pre><code>from time import sleep

def ship_hit(ai_settings, stats, screen, ship, aliens, bullets):
    &quot;&quot;&quot;响应被外星人撞到的飞船&quot;&quot;&quot;
    # 将ships_left减1
    stats.ships_left -= 1

    # 清空外星人列表和子弹列表
    aliens.empty()
    bullets.empty()

    # 创建一群新的外星人，并将飞船放到屏幕底端中央
    create_fleet(ai_settings, screen, ship, aliens)
    ship.center_ship()

    # 暂停
    sleep(0.5)

def update_aliens(ai_settings, stats, screen, ship, aliens, bullets):
    # 检测外星人和飞船碰撞
    if pygame.sprite.spritecollideany(ship, aliens):
        ship_hit(ai_settings, stats, screen, ship, aliens, bullets)
</code></pre><p>然后我们在 ship.py 中添加新方法：</p>
<pre><code>def center_ship(self):
    &quot;&quot;&quot;让飞船在屏幕上居中&quot;&quot;&quot;
    self.center = self.screen_rect.centerx
</code></pre><h3 id="外星人与底部的碰撞"><a href="#外星人与底部的碰撞" class="headerlink" title="外星人与底部的碰撞"></a>外星人与底部的碰撞</h3><p>碰到底部也一样，game over。<br>在 game_functions 中添加新函数：</p>
<pre><code>def check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets):
    &quot;&quot;&quot;检查是否有外星人到达了屏幕底端&quot;&quot;&quot;
    screen_rect = screen.get_rect()
    for alien in aliens.sprites():
        if alien.rect.bottom &gt;= screen_rect.bottom:
            # 像飞船被撞到一样进行处理
            ship_hit(ai_settings, stats, screen, ship, aliens, bullets)
            break
</code></pre><p>修改函数：</p>
<pre><code>def update_aliens(ai_settings, stats, screen, ship, aliens, bullets):
    --snip--
    # 检查是否有外星人到达屏幕底端
    check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets)
</code></pre><h3 id="飞船生命归零"><a href="#飞船生命归零" class="headerlink" title="飞船生命归零"></a>飞船生命归零</h3><p>我们在 game_stats 模块中加入一个标志：</p>
<pre><code>def __init__(self, settings):
    --snip--
    # 游戏刚启动时处于活动状态
    self.game_active = True
</code></pre><p>这个标志将在玩家用完飞船后变为 False，游戏结束。</p>
<p>修改 game_functions :</p>
<pre><code>def ship_hit(ai_settings, stats, screen, ship, aliens, bullets):
    &quot;&quot;&quot;响应飞船被外星人撞到&quot;&quot;&quot;
    if stats.ships_left &gt; 0:
        # 将ships_left减1
        stats.ships_left -= 1

        --snip--

        #暂停一会儿
        sleep(0.5)

    else:
        stats.game_active = False
</code></pre><p>游戏结束，标志为 False，那就不在运行游戏元素。<br>在主程序 while 循环中：</p>
<pre><code>if stats.game_active:
    ship.update()
    gf.update_bullets(ai_settings, screen, ship, aliens, bullets)
    gf.update_aliens(ai_settings, stats, screen, ship, aliens, bullets)
</code></pre><p>游戏结束，窗口将静止。</p>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><ol>
<li>如何在游戏中添加大量相同的元素，如创建一群外星人</li>
<li>如何使用嵌套循环来创建元素网格，还通过调用每个元素的方法 update() 移动了大量的元素</li>
<li>如何控制对象在屏幕上移动的方向，以及如何响应事件，如有外星人到达屏幕边缘</li>
<li>如何检测和响应子弹和外星人碰撞以及外星人和飞船碰撞</li>
<li>如何在游戏中跟踪统计信息，以及如何使用标志 game_active 来判断游戏是否结束了</li>
</ol>
<h1 id="此部分各组件源码"><a href="#此部分各组件源码" class="headerlink" title="此部分各组件源码"></a>此部分各组件源码</h1><h2 id="alien-invasion-py"><a href="#alien-invasion-py" class="headerlink" title="alien_invasion.py"></a>alien_invasion.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line"></span><br><span class="line">from pygame.sprite import Group</span><br><span class="line">from settings import Settings</span><br><span class="line">from ship import Ship</span><br><span class="line">from game_stats import GameStats</span><br><span class="line">import game_functions as gf</span><br><span class="line"></span><br><span class="line">def run_game():</span><br><span class="line">	# 初始化游戏并创建一个屏幕对象</span><br><span class="line">	pygame.init()</span><br><span class="line">	ai_settings = Settings()</span><br><span class="line">	screen = pygame.display.set_mode(</span><br><span class="line">		(ai_settings.screen_width, ai_settings.screen_height))</span><br><span class="line">	pygame.display.set_caption(&quot;Alien Invasion&quot;)	#窗口名称</span><br><span class="line">	</span><br><span class="line">	# 创建一个用于存储游戏统计信息的实例</span><br><span class="line">	stats = GameStats(ai_settings)</span><br><span class="line">	</span><br><span class="line">	# 创建飞船</span><br><span class="line">	ship = Ship(ai_settings, screen)</span><br><span class="line">	</span><br><span class="line">	# 创建一个用于存储子弹的编组</span><br><span class="line">	bullets = Group()</span><br><span class="line">	</span><br><span class="line">	# 创建外星人编组</span><br><span class="line">	aliens = Group()</span><br><span class="line">	</span><br><span class="line">	# 创建外星人群</span><br><span class="line">	gf.create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line">	</span><br><span class="line">	# 开始游戏的主循环</span><br><span class="line">	while True:</span><br><span class="line">		gf.check_events(ai_settings, screen, ship, bullets)</span><br><span class="line">		</span><br><span class="line">		if stats.game_active:</span><br><span class="line">			ship.update()	# 飞船的位置将在检测到键盘事件后（但在更新屏幕前）更新</span><br><span class="line">			gf.update_bullets(ai_settings, screen, ship, aliens, bullets)</span><br><span class="line">			gf.update_aliens(ai_settings, stats, screen, ship, aliens, bullets)</span><br><span class="line">		</span><br><span class="line">		gf.update_screen(ai_settings, screen, ship, aliens, bullets)</span><br><span class="line"></span><br><span class="line">run_game()</span><br></pre></td></tr></table></figure>
<h2 id="game-functions-py"><a href="#game-functions-py" class="headerlink" title="game_functions.py"></a>game_functions.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import pygame</span><br><span class="line">from bullet import Bullet</span><br><span class="line">from alien import Alien</span><br><span class="line">from time import sleep</span><br><span class="line"></span><br><span class="line">def check_keydown_events(event, ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应按键&quot;&quot;&quot;</span><br><span class="line">	if event.key == pygame.K_RIGHT:</span><br><span class="line">		ship.moving_right = True</span><br><span class="line">	elif event.key == pygame.K_LEFT:</span><br><span class="line">		ship.moving_left = True</span><br><span class="line">	elif event.key == pygame.K_SPACE:</span><br><span class="line">		fire_bullet(ai_settings, screen, ship, bullets)</span><br><span class="line">	elif event.key == pygame.K_q:</span><br><span class="line">		sys.exit()</span><br><span class="line"></span><br><span class="line">def check_keyup_events(event, ship):</span><br><span class="line">	&quot;&quot;&quot;响应松开&quot;&quot;&quot;</span><br><span class="line">	if event.key == pygame.K_RIGHT:</span><br><span class="line">		ship.moving_right = False</span><br><span class="line">	elif event.key == pygame.K_LEFT:</span><br><span class="line">		ship.moving_left = False</span><br><span class="line"></span><br><span class="line">def check_events(ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;</span><br><span class="line">	for event in pygame.event.get():</span><br><span class="line">		if event.type == pygame.QUIT:</span><br><span class="line">			sys.exit()</span><br><span class="line">			</span><br><span class="line">		elif event.type == pygame.KEYDOWN:</span><br><span class="line">			check_keydown_events(event, ai_settings, screen, ship, bullets)</span><br><span class="line">		elif event.type == pygame.KEYUP:</span><br><span class="line">			check_keyup_events(event, ship)</span><br><span class="line"></span><br><span class="line">def update_screen(ai_settings, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;更新屏幕上的图像，并切换到新屏幕&quot;&quot;&quot;</span><br><span class="line">	# 每次循环时都重绘屏幕</span><br><span class="line">	screen.fill(ai_settings.bg_color)</span><br><span class="line">	# 重绘所有子弹</span><br><span class="line">	for bullet in bullets.sprites():</span><br><span class="line">		bullet.draw_bullet()</span><br><span class="line">	ship.blitme()</span><br><span class="line">	aliens.draw(screen)	# 括号记得导入窗口参数</span><br><span class="line"></span><br><span class="line">	# 让最近绘制的屏幕可见</span><br><span class="line">	pygame.display.flip()</span><br><span class="line"></span><br><span class="line">def update_bullets(ai_settings, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;</span><br><span class="line">	# 更新子弹的位置</span><br><span class="line">	bullets.update()	# 这步看不懂的话注意一下模块 game_functions.check_keydown_events() 函数</span><br><span class="line">	</span><br><span class="line">	# 删除已消失的子弹</span><br><span class="line">	for bullet in bullets.copy():</span><br><span class="line">		if bullet.rect.bottom &lt;= 0:</span><br><span class="line">			bullets.remove(bullet)</span><br><span class="line">	</span><br><span class="line">	# 响应子弹与外星人的碰撞</span><br><span class="line">	check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets)</span><br><span class="line"></span><br><span class="line">def check_bullet_alien_collisions(ai_settings, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应子弹和外星人的碰撞&quot;&quot;&quot;</span><br><span class="line">	# 删除发生碰撞的子弹和外星人</span><br><span class="line">	collisions = pygame.sprite.groupcollide(bullets, aliens, True, True)</span><br><span class="line">	</span><br><span class="line">	if len(aliens) == 0:</span><br><span class="line">		# 删除现有的所有子弹，并创建一个新的外星人群</span><br><span class="line">		bullets.empty()</span><br><span class="line">		create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line"></span><br><span class="line">def fire_bullet(ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;如果还没有到达限制，就发射一颗子弹&quot;&quot;&quot;</span><br><span class="line">	#创建新子弹，并将其加入到编组bullets中</span><br><span class="line">	if len(bullets) &lt; ai_settings.bullets_allowed:</span><br><span class="line">		new_bullet = Bullet(ai_settings, screen, ship)</span><br><span class="line">		bullets.add(new_bullet)</span><br><span class="line"></span><br><span class="line">def get_number_aliens_x(ai_settings, alien_width):</span><br><span class="line">	&quot;&quot;&quot;计算每行可容纳多少个外星人&quot;&quot;&quot;</span><br><span class="line">	available_space_x = ai_settings.screen_width - 2 * alien_width</span><br><span class="line">	number_aliens_x = int(available_space_x / (2 * alien_width))</span><br><span class="line">	return number_aliens_x</span><br><span class="line"></span><br><span class="line">def get_number_rows(ai_settings, ship_height, alien_height):</span><br><span class="line">	&quot;&quot;&quot;计算屏幕可容纳多少行外星人&quot;&quot;&quot;</span><br><span class="line">	available_space_y = (ai_settings.screen_height - </span><br><span class="line">		(3 * alien_height) - ship_height)</span><br><span class="line">	number_rows = int(available_space_y / (2 * alien_height))</span><br><span class="line">	return number_rows</span><br><span class="line"></span><br><span class="line">def create_alien(ai_settings, screen, aliens, alien_number, row_number):</span><br><span class="line">	&quot;&quot;&quot;创建一个外星人并将其放在当前行&quot;&quot;&quot;</span><br><span class="line">	alien = Alien(ai_settings, screen)</span><br><span class="line">	alien_width = alien.rect.width</span><br><span class="line">	</span><br><span class="line">	# 不要两句并一句，因为在 Alien 类中，我们设定了 alien.x 可以保存小数值</span><br><span class="line">	alien.x = alien_width + 2 * alien_width * alien_number</span><br><span class="line">	alien.rect.x = alien.x</span><br><span class="line">	</span><br><span class="line">	alien.rect.y = alien.rect.height + 2 * alien.rect.height * row_number</span><br><span class="line">	aliens.add(alien)</span><br><span class="line"></span><br><span class="line">def create_fleet(ai_settings, screen, ship, aliens):</span><br><span class="line">	&quot;&quot;&quot;创建外星人群&quot;&quot;&quot;</span><br><span class="line">	# 创建一个外星人，并计算一行可容纳多少个外星人</span><br><span class="line">	# 外星人间距为外星人宽度</span><br><span class="line">	alien = Alien(ai_settings, screen)</span><br><span class="line">	number_aliens_x = get_number_aliens_x(ai_settings, alien.rect.width)</span><br><span class="line">	number_rows = get_number_rows(</span><br><span class="line">		ai_settings, ship.rect.height, alien.rect.height)</span><br><span class="line">	# 创建第一行外星人</span><br><span class="line">	</span><br><span class="line">	for row_number in range(number_rows):</span><br><span class="line">		for alien_number in range(number_aliens_x):</span><br><span class="line">			# 创建一个外星人并将其加入当前行</span><br><span class="line">			create_alien(ai_settings, screen, aliens, alien_number, row_number)</span><br><span class="line">	</span><br><span class="line">def check_fleet_edges(ai_settings, aliens):</span><br><span class="line">	&quot;&quot;&quot;有外星人到达边缘时采取相应的措施&quot;&quot;&quot;</span><br><span class="line">	for alien in aliens.sprites():</span><br><span class="line">		if alien.check_edges():</span><br><span class="line">			change_fleet_direction(ai_settings, aliens)</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">def change_fleet_direction(ai_settings, aliens):</span><br><span class="line">	&quot;&quot;&quot;将整群外星人下移，并改变它们的方向&quot;&quot;&quot;</span><br><span class="line">	for alien in aliens.sprites():</span><br><span class="line">		alien.rect.y += ai_settings.fleet_drop_speed</span><br><span class="line">	ai_settings.fleet_direction *= -1</span><br><span class="line">	</span><br><span class="line">def update_aliens(ai_settings, stats, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;检查是否有外星人位于屏幕边缘，并更新整群外星人的位置&quot;&quot;&quot;</span><br><span class="line">	check_fleet_edges(ai_settings, aliens)</span><br><span class="line">	aliens.update()</span><br><span class="line">	</span><br><span class="line">	# 检测外星人和飞船之间的碰撞</span><br><span class="line">	if pygame.sprite.spritecollideany(ship, aliens):</span><br><span class="line">		ship_hit(ai_settings, stats, screen, ship, aliens, bullets)</span><br><span class="line">	</span><br><span class="line">	# 检查是否有外星人到达屏幕底端</span><br><span class="line">	check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets)</span><br><span class="line"></span><br><span class="line">def check_aliens_bottom(ai_settings, stats, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;检查是否有外星人到达了屏幕底端&quot;&quot;&quot;</span><br><span class="line">	screen_rect = screen.get_rect()</span><br><span class="line">	for alien in aliens.sprites():</span><br><span class="line">		if alien.rect.bottom &gt;= screen_rect.bottom:</span><br><span class="line">			# 像飞船被撞到一样进行处理</span><br><span class="line">			ship_hit(ai_settings, stats, screen, ship, aliens, bullets)</span><br><span class="line">			break</span><br><span class="line"></span><br><span class="line">def ship_hit(ai_settings, stats, screen, ship, aliens, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应被外星人撞到的飞船&quot;&quot;&quot;</span><br><span class="line">	if stats.ships_left &gt; 0:</span><br><span class="line">		# 将ships_left减 1</span><br><span class="line">		stats.ships_left -= 1</span><br><span class="line">		</span><br><span class="line">		# 清空外星人列表和子弹列表</span><br><span class="line">		aliens.empty()</span><br><span class="line">		bullets.empty()</span><br><span class="line">		</span><br><span class="line">		# 创建一群新的外星人，并将飞船放到屏幕底端中央</span><br><span class="line">		create_fleet(ai_settings, screen, ship, aliens)</span><br><span class="line">		ship.center_ship()</span><br><span class="line">		</span><br><span class="line">		# 暂停</span><br><span class="line">		sleep(0.5)</span><br><span class="line">	</span><br><span class="line">	else:</span><br><span class="line">		stats.game_active = False</span><br></pre></td></tr></table></figure>
<h2 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Settings():</span><br><span class="line">	&quot;&quot;&quot;存储《外星人入侵》的所有设置的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self):</span><br><span class="line">		&quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;</span><br><span class="line">		# 屏幕设置</span><br><span class="line">		self.screen_width = 1200</span><br><span class="line">		self.screen_height = 800</span><br><span class="line">		self.bg_color = (230, 230, 230)</span><br><span class="line">		</span><br><span class="line">		# 飞船的设置</span><br><span class="line">		self.ship_speed_factor = 1.5</span><br><span class="line">		self.ship_limit = 3</span><br><span class="line">		</span><br><span class="line">		# 子弹设置</span><br><span class="line">		self.bullet_speed_factor = 1</span><br><span class="line">		self.bullet_width = 3</span><br><span class="line">		self.bullet_height = 15</span><br><span class="line">		self.bullet_color = 60, 60, 60</span><br><span class="line">		self.bullets_allowed = 3</span><br><span class="line">		</span><br><span class="line">		# 外星人设置</span><br><span class="line">		self.alien_speed_factor = 1</span><br><span class="line">		self.fleet_drop_speed = 10</span><br><span class="line">		# fleet_direction 为 1 表示向右移，为 - 1 表示向左移</span><br><span class="line">		self.fleet_direction = 1</span><br></pre></td></tr></table></figure>
<h2 id="ship-py"><a href="#ship-py" class="headerlink" title="ship.py"></a>ship.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line"></span><br><span class="line">class Ship():</span><br><span class="line"></span><br><span class="line">	def __init__(self, ai_settings, screen):</span><br><span class="line">		&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br><span class="line">		self.screen = screen</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		</span><br><span class="line">		# 加载飞船图像并获取其外接矩形</span><br><span class="line">		self.image = pygame.image.load(&apos;images/ship.bmp&apos;)</span><br><span class="line">		self.rect = self.image.get_rect()</span><br><span class="line">		self.screen_rect = screen.get_rect()</span><br><span class="line">		</span><br><span class="line">		# 将每艘新飞船放在屏幕底部中央</span><br><span class="line">		self.rect.centerx = self.screen_rect.centerx</span><br><span class="line">		self.rect.bottom = self.screen_rect.bottom</span><br><span class="line">		</span><br><span class="line">		# 在飞船的属性center中存储小数值</span><br><span class="line">		self.center = float(self.rect.centerx)</span><br><span class="line">		</span><br><span class="line">		# 移动标志</span><br><span class="line">		self.moving_right = False</span><br><span class="line">		self.moving_left = False</span><br><span class="line">		</span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br><span class="line">		# 更新飞船的 center 值，而不是 rect</span><br><span class="line">		if self.moving_right and self.rect.right &lt; self.screen_rect.right:</span><br><span class="line">		# self.rect.right 是飞船图案的右边坐标</span><br><span class="line">			self.center += self.ai_settings.ship_speed_factor</span><br><span class="line">		if self.moving_left and self.rect.left &gt; 0:</span><br><span class="line">			self.center -= self.ai_settings.ship_speed_factor</span><br><span class="line">			</span><br><span class="line">		# 根据self.center更新rect对象</span><br><span class="line">		self.rect.centerx = self.center</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	def blitme(self):</span><br><span class="line">		&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span><br><span class="line">		self.screen.blit(self.image, self.rect)</span><br><span class="line"></span><br><span class="line">	def center_ship(self):</span><br><span class="line">		&quot;&quot;&quot;让飞船在屏幕上居中&quot;&quot;&quot;</span><br><span class="line">		self.center = self.screen_rect.centerx</span><br></pre></td></tr></table></figure>
<h2 id="bullet-py"><a href="#bullet-py" class="headerlink" title="bullet.py"></a>bullet.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line">from pygame.sprite import Sprite</span><br><span class="line"></span><br><span class="line">class Bullet(Sprite):</span><br><span class="line">	&quot;&quot;&quot;一个对飞船发射的子弹进行管理的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, ai_settings, screen, ship):</span><br><span class="line">		&quot;&quot;&quot;在飞船所处的位置创建一个子弹对象&quot;&quot;&quot;</span><br><span class="line">		super().__init__()</span><br><span class="line">		self.screen = screen</span><br><span class="line">		</span><br><span class="line">		# 在(0,0)处创建一个表示子弹的矩形，再设置正确的位置</span><br><span class="line">		self.rect = pygame.Rect(0, 0, ai_settings.bullet_width, ai_settings.bullet_height)</span><br><span class="line">		self.rect.centerx = ship.rect.centerx</span><br><span class="line">		self.rect.top = ship.rect.top</span><br><span class="line">		</span><br><span class="line">		#存储用小数表示的子弹位置</span><br><span class="line">		self.y = float(self.rect.y)</span><br><span class="line">		self.color = ai_settings.bullet_color</span><br><span class="line">		self.speed_factor = ai_settings.bullet_speed_factor</span><br><span class="line">	</span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;</span><br><span class="line">		#更新表示子弹位置的小数值</span><br><span class="line">		self.y -= self.speed_factor</span><br><span class="line">		#更新表示子弹的rect的位置</span><br><span class="line">		self.rect.y = self.y</span><br><span class="line">		</span><br><span class="line">	def draw_bullet(self):</span><br><span class="line">		&quot;&quot;&quot;在屏幕上绘制子弹&quot;&quot;&quot;</span><br><span class="line">		pygame.draw.rect(self.screen, self.color, self.rect)</span><br></pre></td></tr></table></figure>
<h2 id="alien-py"><a href="#alien-py" class="headerlink" title="alien.py"></a>alien.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line"></span><br><span class="line">from pygame.sprite import Sprite</span><br><span class="line"></span><br><span class="line">class Alien(Sprite):</span><br><span class="line">	&quot;&quot;&quot;表示单个外星人的类&quot;&quot;&quot;</span><br><span class="line">	def __init__(self, ai_settings, screen):</span><br><span class="line">		&quot;&quot;&quot;初始化外星人并设置其起始位置&quot;&quot;&quot;</span><br><span class="line">		super().__init__()</span><br><span class="line">		self.screen = screen</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		</span><br><span class="line">		# 加载外星人的图像并矩形化</span><br><span class="line">		self.image = pygame.image.load(&apos;images/alien.bmp&apos;)</span><br><span class="line">		self.rect = self.image.get_rect()</span><br><span class="line">		</span><br><span class="line">		# 设置外星人的左边距、上边距</span><br><span class="line">		#（其实就是令外星人图像左上角的坐标点该位于何方）</span><br><span class="line">		self.rect.x = self.rect.width</span><br><span class="line">		self.rect.y = self.rect.height</span><br><span class="line">		</span><br><span class="line">		# 存储外星人的准确位置</span><br><span class="line">		self.x = float(self.rect.x)</span><br><span class="line">	</span><br><span class="line">	def blitme(self):</span><br><span class="line">		&quot;&quot;&quot;在指定位置绘制外星人&quot;&quot;&quot;</span><br><span class="line">		self.screen.blit(self.image, self.rect)</span><br><span class="line"></span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;左右移动外星人&quot;&quot;&quot;</span><br><span class="line">		self.x += (self.ai_settings.alien_speed_factor * self.ai_settings.fleet_direction)</span><br><span class="line">		self.rect.x = self.x</span><br><span class="line">	</span><br><span class="line">	def check_edges(self):</span><br><span class="line">		&quot;&quot;&quot;如果外星人位于屏幕边缘，就返回True&quot;&quot;&quot;</span><br><span class="line">		screen_rect = self.screen.get_rect()</span><br><span class="line">		if self.rect.right &gt;= screen_rect.right:</span><br><span class="line">			return True</span><br><span class="line">		elif self.rect.left &lt;= 0:</span><br><span class="line">			return True</span><br></pre></td></tr></table></figure>
<h2 id="game-stats-py"><a href="#game-stats-py" class="headerlink" title="game_stats.py"></a>game_stats.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class GameStats():</span><br><span class="line">	&quot;&quot;&quot;跟踪游戏的统计信息&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, ai_settings):</span><br><span class="line">		&quot;&quot;&quot;初始化统计信息&quot;&quot;&quot;</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		self.reset_stats()</span><br><span class="line">		</span><br><span class="line">		# 游戏刚启动时处于活动状态</span><br><span class="line">		self.game_active = True</span><br><span class="line">	</span><br><span class="line">	def reset_stats(self):</span><br><span class="line">		&quot;&quot;&quot;初始化在游戏运行期间可能变化的统计信息&quot;&quot;&quot;</span><br><span class="line">		self.ships_left = self.ai_settings.ship_limit</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/10/02/小游戏之外星人入侵（第一部分）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/10/02/小游戏之外星人入侵（第一部分）/" itemprop="url">小游戏之外星人入侵（第一部分）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-02T23:56:53+08:00">
                2018-10-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><p>写在前面</p></strong></p>
<hr>
<blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<p>拟作一个小游戏项目：<strong>外星人入侵</strong></p>
<blockquote>
<p><em>游戏简介：</em><br>  <em>在游戏《外星人入侵》中，玩家控制着一艘最初出现在屏幕底部中央的飞船。玩家可以使用箭头键左右移动飞船，还可使用空格键进行射击。游戏开始时，一群外星人出现在天空中，他们在屏幕中向下移动。玩家的任务是射杀这些外星人。玩家将所有外星人都消灭干净后，将出现一群新的外星人，他们移动的速度更快。只要有外星人撞到了玩家的飞船或到达了屏幕底部，玩家就损失一艘飞船。玩家损失三艘飞船后，游戏结束。</em></p>
</blockquote>
<p>准备工作：</p>
<ol>
<li>安装 Pygame 模块：打开 cmd ，输入指令：pip install pygame (若出错输入 pip3 ，还出错估计没装 pip)</li>
<li>建立一个项目（也就是新建文件夹），方便统筹。</li>
</ol>
<h1 id="创建窗口"><a href="#创建窗口" class="headerlink" title="创建窗口"></a>创建窗口</h1><p><strong>alien_invasion.py</strong></p>
<hr>
<pre><code>import sys
import pygame

def run_game():
    # 初始化游戏并创建一个屏幕对象
    pygame.init()
    screen = pygame.display.set_mode((1200, 800))
    pygame.display.set_caption(&quot;Alien Invasion&quot;)

    # 开始游戏的主循环
    while True:

        # 监视键盘和鼠标事件
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit()

        # 让最近绘制的屏幕可见
        pygame.display.flip()

run_game()
</code></pre><p>代码解析：</p>
<ol>
<li>开头 pygame.init() 初始化背景设置。</li>
<li>pygame.display.set_mode() 的调用创建名为 screen 的显示窗口，这个游戏的所有图形元素都将在其中绘制。实参(1200, 800)是一个元组，指定了游戏窗口的尺寸。</li>
<li>对象 screen 是一个 surface。在 Pygame 中， surface 是屏幕的一部分，用于显示游戏元素。</li>
<li>Alien Invasion 是窗口的名称，也可以叫游戏名。</li>
<li>设定游戏主循环，并监视用户活动使其能够正常退出。</li>
<li>pygame.display.flip() 它在每次执行 while 循环时都绘制一个空屏幕，并擦去旧屏幕，使得只有新屏幕可见。（刷新）</li>
<li>调用 run_game()，初始化游戏并开始主循环。</li>
</ol>
<h1 id="添加背景色"><a href="#添加背景色" class="headerlink" title="添加背景色"></a>添加背景色</h1><p>在 while 主循环之前，写：</p>
<p><code>bg_color = (230, 230, 230)</code></p>
<p>只用写一次。<br>在 Pygame 中，颜色是以 RGB 值指定。<br>这种颜色由红色、绿色和蓝色值组成，其中每个值的可能取值范围都为 0~255。颜色值(255, 0, 0)表示红色， (0, 255, 0)表示绿色，而(0, 0, 255)表示蓝色。</p>
<p>将 <code>screen.fill(bg_color)</code> 写入 while 循环里面，用背景色填充屏幕。</p>
<p>代码成型：</p>
<pre><code>def run_game():
    # 初始化游戏并创建一个屏幕对象
    pygame.init()
    screen = pygame.display.set_mode((1200, 800))
    pygame.display.set_caption(&quot;Alien Invasion&quot;)    #窗口名称

    # 设置背景色，在Pygame中，颜色是以RGB值指定的。
    bg_color = (230, 230, 230)

    # 开始游戏的主循环
    while True:

        # 监视键盘和鼠标事件
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit()

        # 每次循环时都重绘屏幕
        screen.fill(bg_color)

        # 让最近绘制的屏幕可见
        pygame.display.flip()

run_game()
</code></pre><h1 id="创建设置类"><a href="#创建设置类" class="headerlink" title="创建设置类"></a>创建设置类</h1><p>每次给游戏添加新功能时，通常也将引入一些新设置。下面来编写一个名为 settings 的模块，其中包含一个名为 Settings 的类，用于将所有设置存储在一个地方，以免在代码中到处添加设置。<br><strong>settings.py</strong></p>
<hr>
<pre><code>class Settings():
    &quot;&quot;&quot;存储《外星人入侵》的所有设置的类&quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;
        # 屏幕设置
        self.screen_width = 1200
        self.screen_height = 800
        self.bg_color = (230, 230, 230)
</code></pre><p>这时候主程序就不用那么复杂费劲：</p>
<pre><code>from settings import Settings

def run_game():
    # 初始化游戏并创建一个屏幕对象
    pygame.init()
    ai_settings = Settings()
    screen = pygame.display.set_mode(
        (ai_settings.screen_width, ai_settings.screen_height))
    pygame.display.set_caption(&quot;Alien Invasion&quot;)    #窗口名称

    # 开始游戏的主循环
    while True:

        # 监视键盘和鼠标事件
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                sys.exit()

        # 每次循环时都重绘屏幕
        screen.fill(ai_settings.bg_color)

        # 让最近绘制的屏幕可见
        pygame.display.flip()

run_game()
</code></pre><h1 id="添加飞船及为其创建类"><a href="#添加飞船及为其创建类" class="headerlink" title="添加飞船及为其创建类"></a>添加飞船及为其创建类</h1><p>在游戏中几乎可以使用任何类型的图像文件，但使用位图（.bmp）文件最为简单，因为 Pygame 默认加载位图。<br>如果用别人的图，注意版权，不想费钱可以到 <a href="http://pixabay.com/" target="_blank" rel="noopener">Pixabay</a> 下载想要的图片。<br>这里的飞船用的是原书提供的<a href="https://ehmatthes.github.io/pcc/" target="_blank" rel="noopener">教材资源</a> 。<br>在主项目文件夹内新建一个文件夹 (images) 用于存放飞船图片。</p>
<p>新建 Ship 类：<br><strong>ship.py</strong></p>
<hr>
<pre><code>import pygame

class Ship():

    def __init__(self, screen):        # screen 制定了要将飞船绘制到什么地方
        &quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;
        self.screen = screen

        # 加载飞船图像并获取其外接矩形
        self.image = pygame.image.load(&apos;images/ship.bmp&apos;)
        self.rect = self.image.get_rect()
        # 获取图像的外接矩形，这样就可以用矩形四角和中心的x和y坐标。可通过设置这些值来指定矩形的位置。
        self.screen_rect = screen.get_rect()
        # 将窗口矩形化

        # 将每艘新飞船放在屏幕底部中央
        self.rect.centerx = self.screen_rect.centerx
        self.rect.bottom = self.screen_rect.bottom

    def blitme(self):
        &quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;
        self.screen.blit(self.image, self.rect)
</code></pre><p>要将游戏元素居中，可设置相应 rect 对象的属性 center、 centerx 或 centery。<br>要让游戏元素与屏幕边缘对齐，可使用属性 top、 bottom、 left 或 right。<br>要调整游戏元素的水平或垂直位置，可使用属性 x和 y，它们分别是相应矩形左上角的 x 和 y 坐标。<br>方法 blit()：于窗口中绘制图像。</p>
<p>注意：在Pygame中，原点(0, 0)位于屏幕左上角，向右下方移动时，坐标值将增大。在 1200×800 的屏幕上，原点位于左上角，而右下角的坐标为(1200, 800)。</p>
<h1 id="绘制飞船到主程序中"><a href="#绘制飞船到主程序中" class="headerlink" title="绘制飞船到主程序中"></a>绘制飞船到主程序中</h1><p>导入模块 ship:</p>
<pre><code>from ship import Ship

def run_game():
    --snip--
    pygame.display.set_caption(&quot;Alien Invasion&quot;)    #窗口名称

    # 创建飞船（要在主循环之前，以免每次都重建飞船）
    ship = Ship(screen)

    # 开始游戏的主循环
    while True:
        --snip--
        # 每次循环时都重绘屏幕
        screen.fill(ai_settings.bg_color)

        # 每次循环时都刷新飞船最新位置及图像
        ship.blitme()

        # 让最近绘制的屏幕可见
        pygame.display.flip()

run_game()
</code></pre><h1 id="重构：模块-game-functions"><a href="#重构：模块-game-functions" class="headerlink" title="重构：模块 game_functions"></a>重构：模块 game_functions</h1><p>我们不太可能把所有函数都写在主程序里面，不好维护，也不太好扩展。因此我们要建一个模块来存储游戏函数。<br><strong>game_functions.py</strong></p>
<hr>
<pre><code>import sys
import pygame

def check_events():
    &quot;&quot;&quot;监视键盘和鼠标事件&quot;&quot;&quot;
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

# 有点特殊，当前不需要任何形参 （包括 self）。

def update_screen(ai_settings, screen, ship):
    &quot;&quot;&quot;更新屏幕上的图像，并切换到新屏幕&quot;&quot;&quot;
    # 每次循环时都重绘屏幕
    screen.fill(ai_settings.bg_color)
    ship.blitme()

    # 让最近绘制的屏幕可见
    pygame.display.flip()
</code></pre><p>注意一下，这里虽然用到 ship 参数，不代表要导入模块 ship ，它只是个形参。</p>
<p>然后改一下主函数：</p>
<pre><code>import pygame

from settings import Settings
from ship import Ship
import game_functions as gf

def run_game():
    --snip--
    # 开始游戏主循环
    while True:
        gf.check_events()
        gf.update_screen(ai_settings, screen, ship)
</code></pre><p>可以发现这次我们没有导入包 sys ，因为主函数不再需要，当前只有模块 game_functions 用到了它。<br>可以看到，主循环更加简单易懂，让我们后面做开发更容易一点。<br>所以一开始代码写得简单一些，项目越来越复杂的时候尽可能重构，让开发更简单点。</p>
<h1 id="驾驶飞船"><a href="#驾驶飞船" class="headerlink" title="驾驶飞船"></a>驾驶飞船</h1><h2 id="响应按键"><a href="#响应按键" class="headerlink" title="响应按键"></a>响应按键</h2><p>每当用户按键时，都将在Pygame中注册一个事件。事件都是通过方法 pygame.event.get() 获取的，因此在函数 check_events() 中，我们需要指定要检查哪些类型的事件。<br>每次按键都被注册为一个 KEYDOWN 事件。<br>现在我们设计 右方向键 → ，在模块 game_functions 中设计：</p>
<pre><code>def check_events(ship):
    &quot;&quot;&quot;监视键盘和鼠标事件&quot;&quot;&quot;
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RIGHT:
                #向右移动飞船
                ship.rect.centerx += 1
</code></pre><p>然后，主程序调用需要更新下：<br>    gf.check_events(ship)    # 需要调用实参</p>
<h2 id="持续按键"><a href="#持续按键" class="headerlink" title="持续按键"></a>持续按键</h2><p>如果用户按住右箭头不放，当然是希望能持续移动。我们可以对飞船加个标识，当被按下右箭头时这个标识为 True ：</p>
<pre><code>class Ship():

    def __init__(self, screen):        # screen 制定了要将飞船绘制到什么地方
        &quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;
        self.screen = screen

        # 加载飞船图像并获取其外接矩形
        self.image = pygame.image.load(&apos;images/ship.bmp&apos;)
        self.rect = self.image.get_rect()
        # 获取图像的外接矩形，这样就可以用矩形四角和中心的 x 和 y 坐标。可通过设置这些值来指定矩形的位置
        self.screen_rect = screen.get_rect()
        # 将窗口矩形化

        # 将每艘新飞船放在屏幕底部中央
        self.rect.centerx = self.screen_rect.centerx
        self.rect.bottom = self.screen_rect.bottom


        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	# 移动标志</span><br><span class="line">	self.moving_right = False</span><br><span class="line"></span><br><span class="line">def update(self):</span><br><span class="line">	&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br><span class="line">	if self.moving_right:</span><br><span class="line">	self.rect.centerx += 1</span><br></pre></td></tr></table></figure>



    def blitme(self):
        &quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;
        self.screen.blit(self.image, self.rect)
</code></pre><p>这时候我们就修改一下模块 game_functions：</p>
<pre><code>def check_events(ship):
    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RIGHT:
                ship.moving_right = True

        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_RIGHT:
                ship.moving_right = False
</code></pre><p>最后，我们要整合到主程序里面：</p>
<pre><code>while True:
    gf.check_events(ship)
    `ship.update()`        #飞船的位置将在检测到键盘事件后（但在更新屏幕前）更新。
    gf.update_screen(ai_settings, screen, ship)
</code></pre><p>注意：新增语句要在屏幕刷新之前。</p>
<p>这时候试运行，可以看到飞船向右移动非常快。</p>
<h2 id="左右移动"><a href="#左右移动" class="headerlink" title="左右移动"></a>左右移动</h2><p>向右移动搞定，现在就搞左右移动。<br>最后成型的代码是这样的：<br><strong>alien_invasion.py</strong></p>
<hr>
<pre><code>import pygame

from settings import Settings
from ship import Ship
import game_functions as gf

def run_game():
    # 初始化游戏并创建一个屏幕对象
    pygame.init()
    ai_settings = Settings()
    screen = pygame.display.set_mode(
        (ai_settings.screen_width, ai_settings.screen_height))
    pygame.display.set_caption(&quot;Alien Invasion&quot;)    #窗口名称

    # 创建飞船
    ship = Ship(screen)

    # 开始游戏的主循环
    while True:
        gf.check_events(ship)
        ship.update()    # 飞船的位置将在检测到键盘事件后（但在更新屏幕前）更新。
        gf.update_screen(ai_settings, screen, ship)

run_game()
</code></pre><p><strong>ship.py</strong></p>
<hr>
<pre><code>import pygame

class Ship():

    def __init__(self, screen):
        &quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;
        self.screen = screen

        # 加载飞船图像并获取其外接矩形
        self.image = pygame.image.load(&apos;images/ship.bmp&apos;)
        self.rect = self.image.get_rect()
        self.screen_rect = screen.get_rect()

        # 将每艘新飞船放在屏幕底部中央
        self.rect.centerx = self.screen_rect.centerx
        self.rect.bottom = self.screen_rect.bottom

        # 移动标志
        self.moving_right = False
        self.moving_left = False

    def update(self):
        &quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;
        if self.moving_right:
            self.rect.centerx += 1
        # 这里不用 elif 的原因是玩家可能会同时按着两个键
        if self.moving_left:
            self.rect.centerx -= 1

    def blitme(self):
        &quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;
        self.screen.blit(self.image, self.rect)
</code></pre><p><strong>game_functions.py</strong></p>
<hr>
<pre><code>import sys
import pygame

def check_events(ship):
    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RIGHT:
                ship.moving_right = True
            # 这里之所以用 elif 代码块，是因为每个事件都只与一个键相关联；
            # 如果玩家同时按下了左右箭头键，将检测到两个不同的事件，俩事件相互独立的。
            elif event.key == pygame.K_LEFT:
                ship.moving_left = True

        elif event.type == pygame.KEYUP:
            if event.key == pygame.K_RIGHT:
                ship.moving_right = False
            elif event.key == pygame.K_LEFT:
                ship.moving_left = False

def update_screen(ai_settings, screen, ship):
    &quot;&quot;&quot;更新屏幕上的图像，并切换到新屏幕&quot;&quot;&quot;
    # 每次循环时都重绘屏幕
    screen.fill(ai_settings.bg_color)
    ship.blitme()

    # 让最近绘制的屏幕可见
    pygame.display.flip()
</code></pre><h2 id="飞船速度"><a href="#飞船速度" class="headerlink" title="飞船速度"></a>飞船速度</h2><p>当前飞船移动的像素是 1 。要想加速的话，我们可以在模块 settings.py 里面改：</p>
<pre><code>class Settings():
    &quot;&quot;&quot;存储《外星人入侵》的所有设置的类&quot;&quot;&quot;

    def __init__(self):
        &quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;
        # 屏幕设置
        self.screen_width = 1200
        self.screen_height = 800
        self.bg_color = (230, 230, 230)

        # 飞船的设置
        self.ship_speed_factor = 1.5
</code></pre><p>看到这可能会奇怪，像素只能整型啊，所以我们要对 ship 修改一下：</p>
<p>注意 Ship 要添多一个形参 ai_settings</p>
<pre><code>def __init__(self, ai_settings, screen):
    &quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;
    self.screen = screen
    `self.ai_settings = ai_settings`

    # 加载飞船图像并获取其外接矩形
    ...

    # 将每艘新飞船放在屏幕底部中央
    ...

    # 在飞船的属性center中存储小数值
    self.center = float(self.rect.centerx)

    # 移动标志
    ...

def update(self):
    &quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;
    # 更新飞船的 center 值，而不是 rect
    if self.moving_right:
        self.center += self.ai_settings.ship_speed_factor
    if self.moving_left:
        self.center -= self.ai_settings.ship_speed_factor

    # 根据 self.center 更新 rect 对象
    self.rect.centerx = self.center
    &quot;&quot;&quot;
    注意，这一步很重要，就像 C 语言刚学的时候 a、b 两数交换一样：
    t = a;    a = b;    b = t;
    此时，浮点数转给 rect.centerx 的时候，小数部分会给砍掉，但对飞船而言，问题不大。
    &quot;&quot;&quot;
</code></pre><p>然后就是对主程序修改：</p>
<pre><code>def run_game():
    --snip--
    # 创建飞船
    ship = Ship(ai_settings, screen)
</code></pre><h1 id="限制飞船活动范围"><a href="#限制飞船活动范围" class="headerlink" title="限制飞船活动范围"></a>限制飞船活动范围</h1><p>发现没？一直按着方向键，他会出界，看不到飞船了。<br>要给 Ship() 加个撞墙机制。</p>
<pre><code>class Ship():
    def update(self):
        &quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;
        # 更新飞船的 center 值，而不是 rect
        if self.moving_right and self.rect.right &lt; self.screen_rect.right:
        # self.rect.right 是飞船图案的右边坐标
            self.center += self.ai_settings.ship_speed_factor
        if self.moving_left and self.rect.left &gt; 0:
            self.center -= self.ai_settings.ship_speed_factor

        # 根据self.center更新rect对象
        self.rect.centerx = self.center
</code></pre><h1 id="继续重构：game-functions"><a href="#继续重构：game-functions" class="headerlink" title="继续重构：game_functions"></a>继续重构：game_functions</h1><p>回过头来看，check_events() 还可以更精简一些，修一修：</p>
<pre><code>def check_keydown_events(event, ship):
    &quot;&quot;&quot;响应按键&quot;&quot;&quot;
    if event.key == pygame.K_RIGHT:
        ship.moving_right = True
    elif event.key == pygame.K_LEFT:
        ship.moving_left = True

def check_keyup_events(event, ship):
    &quot;&quot;&quot;响应松开&quot;&quot;&quot;
    if event.key == pygame.K_RIGHT:
        ship.moving_right = False
    elif event.key == pygame.K_LEFT:
        ship.moving_left = False

def check_events(ship):
    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            check_keydown_events(event, ship)
        elif event.type == pygame.KEYUP:
            check_keyup_events(event, ship)
</code></pre><h1 id="子弹"><a href="#子弹" class="headerlink" title="子弹"></a>子弹</h1><p>添加射击功能。子弹将在屏幕中向上穿行，抵达屏幕上边缘后消失。<br>更新 模块 settings.py：</p>
<pre><code>def __init__(self):
    --snip--
    # 子弹设置
    self.bullet_speed_factor = 1
    self.bullet_width = 3
    self.bullet_height = 15
    self.bullet_color = 60, 60, 60
</code></pre><p>建立一个新模块 bullet.py, 用于存放子弹相关设置。<br><strong>bullet.py</strong></p>
<hr>
<pre><code>import pygame
from pygame.sprite import Sprite

class Bullet(Sprite):
    &quot;&quot;&quot;一个对飞船发射的子弹进行管理的类&quot;&quot;&quot;

    def __init__(self, ai_settings, screen, ship):
        &quot;&quot;&quot;在飞船所处的位置创建一个子弹对象&quot;&quot;&quot;
        super().__init__()
        self.screen = screen

        # 在(0,0)处创建一个表示子弹的矩形，再设置正确的位置
        self.rect = pygame.Rect(0, 0, ai_settings.bullet_width, ai_settings.bullet_height)
        self.rect.centerx = ship.rect.centerx
        self.rect.top = ship.rect.top

        #存储用小数表示的子弹位置
        self.y = float(self.rect.y)
        self.color = ai_settings.bullet_color
        self.speed_factor = ai_settings.bullet_speed_factor

    def update(self):
        &quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;
        #更新表示子弹位置的小数值
        self.y -= self.speed_factor
        #更新表示子弹的rect的位置
        self.rect.y = self.y

    def draw_bullet(self):
        &quot;&quot;&quot;在屏幕上绘制子弹&quot;&quot;&quot;
        pygame.draw.rect(self.screen, self.color, self.rect)
</code></pre><p>这里我们导入了精灵模块 (pygame.sprite) 中的 Sprite。这儿干嘛用的？为什么要有这个类呢？<br>举个例子大家就明白了。在一款 RPG 游戏中（如：口袋妖怪），我们的地图上有树林、小河等一系列地图元件。玩过此类游戏的同学都知道，如果我们的人物走到了地图中央继续前进的话，地图会进行卷轴移动，显示出下部分地图。这个时候我们如果要把每个地图元件进行移动，操作起来会相当麻烦。因此 flash 为我们提供的 Sprite 就是为了统一处理一系列显示对象而生的。<br>简单来讲就是会动的、可以和其他图像交互的图片。具体更详细的介绍，可以参考<a href="https://blog.csdn.net/zengxiantao1994/article/details/64922278" target="_blank" rel="noopener">这篇文章</a> 。</p>
<h1 id="导入子弹"><a href="#导入子弹" class="headerlink" title="导入子弹"></a>导入子弹</h1><p>子弹做好后，导入到主程序中：<br>这时还要导入模块 pygame.sprite 中的 Group 类（精灵组管理类），它类似于列表，但提供了有助于开发游戏的额外功能。</p>
<pre><code>import pygame
from pygame.sprite import Group
--snip--

def run_game():
    --snip--
    # 创建一艘飞船
    ship = Ship(ai_settings, screen)
    # 创建一个用于存储子弹的编组
    bullets = Group()
    &quot;&quot;&quot;
    如果在循环内部创建这样的编组，游戏运行时将创建数千个子弹编组，导致游戏慢得像蜗牛。如果游戏停滞不前，请仔细查看主while循环中发生的情况。
    &quot;&quot;&quot;

    # 开始游戏主循环
    while True:
        gf.check_events(ai_settings, screen, ship, bullets)
        ship.update()
        bullets.update()    # 这步看不懂的话注意一下接下来模块 game_functions.check_keydown_events() 函数的修改
        gf.update_screen(ai_settings, screen, ship, bullets)

run_game()
</code></pre><h1 id="开火功能"><a href="#开火功能" class="headerlink" title="开火功能"></a>开火功能</h1><p>这时候，子弹的构建差不多了，接下来就是响应玩家的按键事件。<br>修改模块 game_functions:<br>    from bullet import Bullet</p>
<pre><code>def check_keydown_events(event, ai_settings, screen, ship, bullets):
    &quot;&quot;&quot;响应按键&quot;&quot;&quot;
    if event.key == pygame.K_RIGHT:
        ship.moving_right = True
    elif event.key == pygame.K_LEFT:
        ship.moving_left = True
    elif event.key == pygame.K_SPACE:
        # 创建一颗子弹，并将其加入到编组 bullets 中
        new_bullet = Bullet(ai_settings, screen, ship)
        bullets.add(new_bullet)

def check_events(ai_settings, screen, ship, bullets):
    &quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            sys.exit()

        elif event.type == pygame.KEYDOWN:
            check_keydown_events(event, ai_settings, screen, ship, bullets)
        elif event.type == pygame.KEYUP:
            check_keyup_events(event, ship)
</code></pre><h1 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h1><p>其实，我们写出来的子弹都没消失，发射出去触顶后消失只是我们看不到界外而已，所以我们要让这些触顶子弹消失。<br>在主程序的 while 循环中修改：</p>
<pre><code># 删除已消失的子弹
for bullet in bullets.copy():
    if bullet.rect.bottom &lt;= 0:
        bullets.remove(bullet)
print(len(bullets))
</code></pre><p>上面的 print 语句只是为了检验一下代码有没有问题，子弹是否有被删除，没问题的话就删掉。<br>此外，在 for 循环中，不应从列表或编组中删除条目，因此必须遍历编组的副本。因为不能随便用切片法建立副本，而且我们要遍历的对象特殊（精灵动图），可能出错，所以我们用方法 copy() 建立副本（这方法属于 Group 类）。<br></p>
<h1 id="限制子弹数量（可选）"><a href="#限制子弹数量（可选）" class="headerlink" title="限制子弹数量（可选）"></a>限制子弹数量（可选）</h1><p>如果想给游戏增加难度，不妨限制一下子弹显示在屏幕的最大数量。<br>首先设置一下模块 settings.py，给子弹新增一个状态:<br><code>self.bullets_allowed = 3</code><br>表示子弹留存量只有 3 颗。<br>然后，在模块 game_functions 中写入检查看看还能不能再发射子弹：</p>
<pre><code>elif event.key == pygame.K_SPACE:
    # 创建一颗子弹，并将其加入到编组 bullets 中
    if len(bullets) &lt; ai_settings.bullets_allowed:
        new_bullet = Bullet(ai_settings, screen, ship)
        bullets.add(new_bullet)
</code></pre><h1 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h1><p>我们新增了限制子弹、发射子弹的功能，那能不能再精简一波？<br>试试创建函数 update_bullets()，用以保存子弹的刷新。</p>
<pre><code>def update_bullets(bullets):
    &quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;
    # 更新子弹的位置
    bullets.update()

    # 删除已消失的子弹
    for bullet in bullets.copy():
        if bullet.rect.bottom &lt;= 0:
            bullets.remove(bullet)
</code></pre><p>这时候我们就可以把主程序中子弹相关的代码转移到模块 game_functions 了。<br>这时候，while 循环代码成了这样：</p>
<pre><code>while True:
    gf.check_events(ai_settings, screen, ship, bullets)
    ship.update()
    gf.update_bullets(bullets)
    gf.update_screen(ai_settings, screen, ship, bullets)
</code></pre><p>很简洁，一目了然。</p>
<p>接下来还可以继续重构发射子弹功能。</p>
<pre><code>def fire_bullet(ai_settings, screen, ship, bullets):
    &quot;&quot;&quot;如果还没有到达限制，就发射一颗子弹&quot;&quot;&quot;
    #创建新子弹，并将其加入到编组bullets中
    if len(bullets) &lt; ai_settings.bullets_allowed:
        new_bullet = Bullet(ai_settings, screen, ship)
        bullets.add(new_bullet)
</code></pre><p>然后 check_keydown_events() 函数就可以得到精简：</p>
<pre><code>elif event.key == pygame.K_SPACE:
    fire_bullet(ai_settings, screen, ship, bullets)
</code></pre><p>写到这里也可以明白了，不是说一开始就要追着代码精简力求规划整齐，而是先实现功能，再考虑代码重构，慢慢来。<br>如果想一上手就写好精致简洁的代码，在开发项目之前就要画好蓝图，想好要什么功能，如何将这些链接起来等等，所以整体观念很重要。</p>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><pre><code>1. 游戏开发计划的如何制定
2. 如何使用 Pygame 编写游戏的基本结构
3. 如何设置背景色，以及如何将设置存储在可供游戏的各个部分访问的独立类中
4. 如何在屏幕上绘制图像，以及如何让玩家控制游戏元素的移动
5. 如何创建自动移动的元素，如在屏幕中向上飞驰的子弹，以及如何删除不再需要的对象
6. 如何定期重构项目的代码，为后续开发提供便利
</code></pre><h1 id="此部分各组件源码"><a href="#此部分各组件源码" class="headerlink" title="此部分各组件源码"></a>此部分各组件源码</h1><h2 id="alien-invasion-py"><a href="#alien-invasion-py" class="headerlink" title="alien_invasion.py"></a>alien_invasion.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line"></span><br><span class="line">from pygame.sprite import Group</span><br><span class="line">from settings import Settings</span><br><span class="line">from ship import Ship</span><br><span class="line">import game_functions as gf</span><br><span class="line"></span><br><span class="line">def run_game():</span><br><span class="line">	# 初始化游戏并创建一个屏幕对象</span><br><span class="line">	pygame.init()</span><br><span class="line">	ai_settings = Settings()</span><br><span class="line">	screen = pygame.display.set_mode(</span><br><span class="line">		(ai_settings.screen_width, ai_settings.screen_height))</span><br><span class="line">	pygame.display.set_caption(&quot;Alien Invasion&quot;)	#窗口名称</span><br><span class="line">	</span><br><span class="line">	# 创建飞船</span><br><span class="line">	ship = Ship(ai_settings, screen)</span><br><span class="line">	</span><br><span class="line">	# 创建一个用于存储子弹的编组</span><br><span class="line">	bullets = Group()</span><br><span class="line">	</span><br><span class="line">	# 开始游戏的主循环</span><br><span class="line">	while True:</span><br><span class="line">		gf.check_events(ai_settings, screen, ship, bullets)</span><br><span class="line">		ship.update()	# 飞船的位置将在检测到键盘事件后（但在更新屏幕前）更新</span><br><span class="line">		gf.update_bullets(bullets)</span><br><span class="line">		gf.update_screen(ai_settings, screen, ship, bullets)</span><br><span class="line"></span><br><span class="line">run_game()</span><br></pre></td></tr></table></figure>
<h2 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Settings():</span><br><span class="line">	&quot;&quot;&quot;存储《外星人入侵》的所有设置的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self):</span><br><span class="line">		&quot;&quot;&quot;初始化游戏的设置&quot;&quot;&quot;</span><br><span class="line">		# 屏幕设置</span><br><span class="line">		self.screen_width = 1200</span><br><span class="line">		self.screen_height = 800</span><br><span class="line">		self.bg_color = (230, 230, 230)</span><br><span class="line">		</span><br><span class="line">		# 飞船的设置</span><br><span class="line">		self.ship_speed_factor = 1.5</span><br><span class="line">		</span><br><span class="line">		# 子弹设置</span><br><span class="line">		self.bullet_speed_factor = 1</span><br><span class="line">		self.bullet_width = 3</span><br><span class="line">		self.bullet_height = 15</span><br><span class="line">		self.bullet_color = 60, 60, 60</span><br><span class="line">		self.bullets_allowed = 3</span><br></pre></td></tr></table></figure>
<h2 id="game-functions-py"><a href="#game-functions-py" class="headerlink" title="game_functions.py"></a>game_functions.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">import pygame</span><br><span class="line">from bullet import Bullet</span><br><span class="line"></span><br><span class="line">def check_keydown_events(event, ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应按键&quot;&quot;&quot;</span><br><span class="line">	if event.key == pygame.K_RIGHT:</span><br><span class="line">		ship.moving_right = True</span><br><span class="line">	elif event.key == pygame.K_LEFT:</span><br><span class="line">		ship.moving_left = True</span><br><span class="line">	elif event.key == pygame.K_SPACE:</span><br><span class="line">		fire_bullet(ai_settings, screen, ship, bullets)</span><br><span class="line"></span><br><span class="line">def check_keyup_events(event, ship):</span><br><span class="line">	&quot;&quot;&quot;响应松开&quot;&quot;&quot;</span><br><span class="line">	if event.key == pygame.K_RIGHT:</span><br><span class="line">		ship.moving_right = False</span><br><span class="line">	elif event.key == pygame.K_LEFT:</span><br><span class="line">		ship.moving_left = False</span><br><span class="line"></span><br><span class="line">def check_events(ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;响应按键和鼠标事件&quot;&quot;&quot;</span><br><span class="line">	for event in pygame.event.get():</span><br><span class="line">		if event.type == pygame.QUIT:</span><br><span class="line">			sys.exit()</span><br><span class="line">			</span><br><span class="line">		elif event.type == pygame.KEYDOWN:</span><br><span class="line">			check_keydown_events(event, ai_settings, screen, ship, bullets)</span><br><span class="line">		elif event.type == pygame.KEYUP:</span><br><span class="line">			check_keyup_events(event, ship)</span><br><span class="line"></span><br><span class="line">def update_screen(ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;更新屏幕上的图像，并切换到新屏幕&quot;&quot;&quot;</span><br><span class="line">	# 每次循环时都重绘屏幕</span><br><span class="line">	screen.fill(ai_settings.bg_color)</span><br><span class="line">	# 重绘所有子弹</span><br><span class="line">	for bullet in bullets.sprites():</span><br><span class="line">		bullet.draw_bullet()</span><br><span class="line">	ship.blitme()</span><br><span class="line"></span><br><span class="line">	# 让最近绘制的屏幕可见</span><br><span class="line">	pygame.display.flip()</span><br><span class="line"></span><br><span class="line">def update_bullets(bullets):</span><br><span class="line">	&quot;&quot;&quot;更新子弹的位置，并删除已消失的子弹&quot;&quot;&quot;</span><br><span class="line">	# 更新子弹的位置</span><br><span class="line">	bullets.update()	# 这步看不懂的话注意一下模块 game_functions.check_keydown_events() 函数</span><br><span class="line">	</span><br><span class="line">	# 删除已消失的子弹</span><br><span class="line">	for bullet in bullets.copy():</span><br><span class="line">		if bullet.rect.bottom &lt;= 0:</span><br><span class="line">			bullets.remove(bullet)</span><br><span class="line"></span><br><span class="line">def fire_bullet(ai_settings, screen, ship, bullets):</span><br><span class="line">	&quot;&quot;&quot;如果还没有到达限制，就发射一颗子弹&quot;&quot;&quot;</span><br><span class="line">	#创建新子弹，并将其加入到编组bullets中</span><br><span class="line">	if len(bullets) &lt; ai_settings.bullets_allowed:</span><br><span class="line">		new_bullet = Bullet(ai_settings, screen, ship)</span><br><span class="line">		bullets.add(new_bullet)</span><br></pre></td></tr></table></figure>
<h2 id="ship-py"><a href="#ship-py" class="headerlink" title="ship.py"></a>ship.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line"></span><br><span class="line">class Ship():</span><br><span class="line"></span><br><span class="line">	def __init__(self, ai_settings, screen):</span><br><span class="line">		&quot;&quot;&quot;初始化飞船并设置其初始位置&quot;&quot;&quot;</span><br><span class="line">		self.screen = screen</span><br><span class="line">		self.ai_settings = ai_settings</span><br><span class="line">		</span><br><span class="line">		# 加载飞船图像并获取其外接矩形</span><br><span class="line">		self.image = pygame.image.load(&apos;images/ship.bmp&apos;)</span><br><span class="line">		self.rect = self.image.get_rect()</span><br><span class="line">		self.screen_rect = screen.get_rect()</span><br><span class="line">		</span><br><span class="line">		# 将每艘新飞船放在屏幕底部中央</span><br><span class="line">		self.rect.centerx = self.screen_rect.centerx</span><br><span class="line">		self.rect.bottom = self.screen_rect.bottom</span><br><span class="line">		</span><br><span class="line">		# 在飞船的属性center中存储小数值</span><br><span class="line">		self.center = float(self.rect.centerx)</span><br><span class="line">		</span><br><span class="line">		# 移动标志</span><br><span class="line">		self.moving_right = False</span><br><span class="line">		self.moving_left = False</span><br><span class="line">		</span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;根据移动标志调整飞船的位置&quot;&quot;&quot;</span><br><span class="line">		# 更新飞船的 center 值，而不是 rect</span><br><span class="line">		if self.moving_right and self.rect.right &lt; self.screen_rect.right:</span><br><span class="line">		# self.rect.right 是飞船图案的右边坐标</span><br><span class="line">			self.center += self.ai_settings.ship_speed_factor</span><br><span class="line">		if self.moving_left and self.rect.left &gt; 0:</span><br><span class="line">			self.center -= self.ai_settings.ship_speed_factor</span><br><span class="line">			</span><br><span class="line">		# 根据self.center更新rect对象</span><br><span class="line">		self.rect.centerx = self.center</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	def blitme(self):</span><br><span class="line">		&quot;&quot;&quot;在指定位置绘制飞船&quot;&quot;&quot;</span><br><span class="line">		self.screen.blit(self.image, self.rect)</span><br></pre></td></tr></table></figure>
<h2 id="bullet-py"><a href="#bullet-py" class="headerlink" title="bullet.py"></a>bullet.py</h2><hr>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import pygame</span><br><span class="line">from pygame.sprite import Sprite</span><br><span class="line"></span><br><span class="line">class Bullet(Sprite):</span><br><span class="line">	&quot;&quot;&quot;一个对飞船发射的子弹进行管理的类&quot;&quot;&quot;</span><br><span class="line">	</span><br><span class="line">	def __init__(self, ai_settings, screen, ship):</span><br><span class="line">		&quot;&quot;&quot;在飞船所处的位置创建一个子弹对象&quot;&quot;&quot;</span><br><span class="line">		super().__init__()</span><br><span class="line">		self.screen = screen</span><br><span class="line">		</span><br><span class="line">		# 在(0,0)处创建一个表示子弹的矩形，再设置正确的位置</span><br><span class="line">		self.rect = pygame.Rect(0, 0, ai_settings.bullet_width, ai_settings.bullet_height)</span><br><span class="line">		self.rect.centerx = ship.rect.centerx</span><br><span class="line">		self.rect.top = ship.rect.top</span><br><span class="line">		</span><br><span class="line">		#存储用小数表示的子弹位置</span><br><span class="line">		self.y = float(self.rect.y)</span><br><span class="line">		self.color = ai_settings.bullet_color</span><br><span class="line">		self.speed_factor = ai_settings.bullet_speed_factor</span><br><span class="line">	</span><br><span class="line">	def update(self):</span><br><span class="line">		&quot;&quot;&quot;向上移动子弹&quot;&quot;&quot;</span><br><span class="line">		#更新表示子弹位置的小数值</span><br><span class="line">		self.y -= self.speed_factor</span><br><span class="line">		#更新表示子弹的rect的位置</span><br><span class="line">		self.rect.y = self.y</span><br><span class="line">		</span><br><span class="line">	def draw_bullet(self):</span><br><span class="line">		&quot;&quot;&quot;在屏幕上绘制子弹&quot;&quot;&quot;</span><br><span class="line">		pygame.draw.rect(self.screen, self.color, self.rect)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/09/28/代码测试/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/09/28/代码测试/" itemprop="url">代码测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-28T18:02:54+08:00">
                2018-09-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><p>写在前面</p></strong></p>
<hr>
<blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<hr>
<p>写完代码，总是要测试一遍以确保能够运行得到预期的答案。然而总不可能每次都要调后台输入实参，这时候我们可以使用 Python 提供的自动测试。</p>
<hr>
<h1 id="函数测试"><a href="#函数测试" class="headerlink" title="函数测试"></a>函数测试</h1><p>写一个模块：<br>name_function.py</p>
<pre><code>def get_formatted_name(first, last):
    &quot;&quot;&quot;Generate a neatly formatted full name.&quot;&quot;&quot;
    full_name = first + &apos; &apos; + last
    return full_name.title()
</code></pre><p>测试：<br>test_name_ function.py</p>
<pre><code>import unittest
from name_function import get_formatted_name

class NamesTestCase(unittest.TestCase):        #这里必须继承自 unittest.TestCase 类，让 Python 知道如何运行所编写的测试
    &quot;&quot;&quot;测试name_function.py&quot;&quot;&quot;

    def test_first_last_name(self):
        &quot;&quot;&quot;能够正确地处理像Janis Joplin这样的姓名吗？ &quot;&quot;&quot;
        formatted_name = get_formatted_name(&apos;janis&apos;, &apos;joplin&apos;)
        self.assertEqual(formatted_name, &apos;Janis Joplin&apos;)

unittest.main()        #让 Python 启动对此段代码的测试
</code></pre><p>out：</p>
<pre><code>.
----------------------------------------------------------------------
Ran 1 test in 0.000s
OK
</code></pre><ol>
<li>unittest 是 Python 标准库中的模块，它提供了代码测试工具。</li>
<li>所有以 test_ 打头的方法都将自动运行。（继承自 unittest.TestCase 类）</li>
<li>assertEqual()：断言方法。断言方法用来核实得到的结果是否与期望的结果一致。（属于 unittest 类）</li>
<li>每完成一个单元测试， Python 都打印一个字符：测试通过时打印一个句点；测试引发错误时打印一个E；测试导致断言失败时打印一个F。</li>
</ol>
<p>当然，如果测试错误，将弹出以下报警：</p>
<pre><code>F
======================================================================
FAIL: test_first_last_name (__main__.NamesTestCase)
能够正确地处理像Janis Joplin这样的姓名吗？
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;C:\Users\GR\Desktop\asd.py&quot;, line 10, in test_first_last_name
    self.assertEqual(formatted_name, &apos;JanisJoplin&apos;)
AssertionError: &apos;Janis Joplin&apos; != &apos;JanisJoplin&apos;
- Janis Joplin
?      -
+ JanisJoplin


----------------------------------------------------------------------
Ran 1 test in 0.001s

FAILED (failures=1)
</code></pre><p>匹配失败。<br>它指出测试失败的原因及源代码具体位置，还指出有多少错误（ FAILED (failures=1) ），方便调试。</p>
<h1 id="测试未通过处理"><a href="#测试未通过处理" class="headerlink" title="测试未通过处理"></a>测试未通过处理</h1><p>这次，我们更新模块 name_function.py：</p>
<pre><code>def get_formatted_name(first, middle, last):
    &quot;&quot;&quot;生成整洁的姓名&quot;&quot;&quot;
    full_name = first + &apos; &apos; + middle + &apos; &apos; + last
    return full_name.title()
</code></pre><p>如果我们还用上述的测试代码，明显通不过：</p>
<pre><code>E
======================================================================
ERROR: test_first_last_name (__main__.NamesTestCase)
能够正确地处理像Janis Joplin这样的姓名吗？
----------------------------------------------------------------------
Traceback (most recent call last):
  File &quot;C:\Users\GR\Desktop\asd.py&quot;, line 9, in test_first_last_name
    formatted_name = get_formatted_name(&apos;janis&apos;, &apos;joplin&apos;)
TypeError: get_formatted_name() missing 1 required positional argument: &apos;last&apos;

----------------------------------------------------------------------
Ran 1 test in 0.000s

FAILED (errors=1)
</code></pre><p>匹配错误。<br>第一行字母 E 表示测试用例中有一个单元测试导致了错误。<br>第二行的 ERROR: 指出错的是哪个单元测试用例。</p>
<p>这时候，不要忙着修复测试代码，而是先考虑修复导致测试不能通过的代码（新写的代码）。</p>
<p>我们改一下 get_formatted_name 的代码：</p>
<pre><code>def get_formatted_name(first, last, middle=&apos;&apos;):
    &quot;&quot;&quot;生成整洁的姓名&quot;&quot;&quot;
    if middle:
        full_name = first + &apos; &apos; + middle + &apos; &apos; + last
    else:
        full_name = first + &apos; &apos; + last
    return full_name.title()
</code></pre><p>让中间名变为可选的变量。<br>结果当然的，能够通过。</p>
<h1 id="添加新测试"><a href="#添加新测试" class="headerlink" title="添加新测试"></a>添加新测试</h1><p>可以看到，我们更新了 get_formatted_name 函数，但是不知道能否输出包含中间名的完整名字。<br>在上述的 NamesTestCase 类中，我们再加一段新的测试代码：</p>
<pre><code>def test_first_last_middle_name(self):        #注意必须 test_ 打头，这样 Python 才会自动运行
    &quot;&quot;&quot;能够正确地处理像Wolfgang Amadeus Mozart这样的姓名吗？ &quot;&quot;&quot;
    formatted_name = get_formatted_name(
        &apos;wolfgang&apos;, &apos;mozart&apos;, &apos;amadeus&apos;)
    self.assertEqual(formatted_name, &apos;Wolfgang Amadeus Mozart&apos;)
</code></pre><p>out：</p>
<pre><code>..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
</code></pre><h1 id="断言方法"><a href="#断言方法" class="headerlink" title="断言方法"></a>断言方法</h1><p>Python 在 unittest.TestCase 类中提供了很多断言方法。<br>以下为常用的断言方法：<br><img src="/ganru.github.io/2018/09/28/代码测试/1.png"></p>
<h1 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h1><p>函数知道怎么测试了，现在看看类的测试。<br>写一个类模块：<br>survey.py</p>
<pre><code>class AnonymousSurvey():
    &quot;&quot;&quot;收集匿名调查问卷的答案&quot;&quot;&quot;

    def __init__(self, question):
        &quot;&quot;&quot;存储一个问题，并为存储答案做准备&quot;&quot;&quot;
        self.question = question
        self.responses = []

    def show_question(self):
        &quot;&quot;&quot;显示调查问卷&quot;&quot;&quot;
        print(question)

    def store_response(self, new_response):
        &quot;&quot;&quot;存储单份调查答卷&quot;&quot;&quot;
        self.responses.append(new_response)

    def show_results(self):
        &quot;&quot;&quot;显示收集到的所有答卷&quot;&quot;&quot;
        print(&quot;Survey results:&quot;)
        for response in responses:
            print(&apos;- &apos; + response)
</code></pre><p>测试代码：<br>test_survey.py</p>
<pre><code>import unittest
from survey import AnonymousSurvey

class TestAnonmyousSurvey(unittest.TestCase):
    &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;

    def test_store_single_response(self):
        &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
        question = &quot;What language did you first learn to speak?&quot;
        my_survey = AnonymousSurvey(question)
        my_survey.store_response(&apos;English&apos;)

        self.assertIn(&apos;English&apos;, my_survey.responses)

    def test_store_three_responses(self):
        &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
        question = &quot;What language did you first learn to speak?&quot;
        my_survey = AnonymousSurvey(question)
        responses = [&apos;English&apos;, &apos;Spanish&apos;, &apos;Mandarin&apos;]
        for response in responses:
            my_survey.store_response(response)
        for response in responses:
            self.assertIn(response, my_survey.responses)

unittest.main()
</code></pre><p>out：</p>
<pre><code>..
----------------------------------------------------------------------
Ran 2 tests in 0.000s

OK
</code></pre><h1 id="方法-setUp"><a href="#方法-setUp" class="headerlink" title="方法 setUp()"></a>方法 setUp()</h1><p>unittest.TestCase 类包含方法 setUp()，让我们只需创建这些对象一次，并在每个测试方法中使用它们。<br>如果在 TestCase 类中包含了方法 setUp()， Python 将先运行它，再运行各个以 test_ 打头的方法。</p>
<p>修改一下 class TestAnonmyousSurvey：</p>
<pre><code>class TestAnonmyousSurvey(unittest.TestCase):
    &quot;&quot;&quot;针对AnonymousSurvey类的测试&quot;&quot;&quot;

    def setUp(self):
        &quot;&quot;&quot;创建一个调查对象和一组答案，供使用的测试方法使用&quot;&quot;&quot;
        question = &quot;What language did you first learn to speak?&quot;
        self.my_survey = AnonymousSurvey(question)
        self.responses = [&apos;English&apos;, &apos;Spanish&apos;, &apos;Mandarin&apos;]

    def test_store_single_response(self):
        &quot;&quot;&quot;测试单个答案会被妥善地存储&quot;&quot;&quot;
        self.my_survey.store_response(self.responses[0])
        self.assertIn(self.responses[0], self.my_survey.responses)

    def test_store_three_responses(self):
        &quot;&quot;&quot;测试三个答案会被妥善地存储&quot;&quot;&quot;
        for response in self.responses:
            self.my_survey.store_response(response)
        for response in self.responses:
            self.assertIn(response, self.my_survey.responses)
</code></pre><p>运行结果相同。</p>
<p>运用方法 setUp() 很省事，不用建立这么多对象一个一个测，减少内存占用率。</p>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><ol>
<li>如何使用模块unittest中的工具来为函数和类编写测试</li>
<li>如何编写继承unittest.TestCase的类</li>
<li>如何使用方法setUp()</li>
<li>注意编写重要行为的测试</li>
<li>在项目早期，不要试图去编写全覆盖的测试用例，除非有充分的理由这样做，不然影响开发速度</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/09/27/文件与异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/09/27/文件与异常/" itemprop="url">文件与异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T17:13:50+08:00">
                2018-09-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><p>写在前面</p></strong></p>
<hr>
<blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<h1 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h1><p>首先尝试建立一个 .txt 文件，也可以像这样：<br>pi.txt：</p>
<pre><code>3.1415926535
  8979323846
  2643383279
</code></pre><p>然后另建一个 .py 文件，内容如下:</p>
<pre><code>with open(&apos;pi.txt&apos;) as file_object:
    contents = file_object.read()
    print(contents)
</code></pre><p>在这里，open 函数返回一个表示文件pi.txt的对象。<br>注意：如果没写绝对路径，则 Python 将在 .py 文件所在目录搜索 pi.txt 文件。</p>
<p>当然，如果想删除空行：<br><code>print(contents.lstrip())</code></p>
<h1 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h1><p>随系统不同，文件路径搜索方式也不同：</p>
<p>Linux 与 OS X：with open(‘desktop/pi.txt’) as file_object:    （斜杠/）<br>Windows：with open(‘desktop\pi.txt’) as file_object:    （反斜杠\）</p>
<p>上述两种是相对路径查找，如果想明确指出文件所在，可用绝对路径。不过很长，可存储到变量中：</p>
<p>Linux 与 OS X：<br>file_path = ‘/home/ehmatthes/other_files/text_files/filename.txt’    （斜杠/）<br>with open(file_path) as file_object:</p>
<p>Windows：<br>file_path = ‘C:\Users\ehmatthes\other_files\text_files\filename.txt’    （反斜杠\）<br>with open(file_path)) as file_object:</p>
<h1 id="逐行读取"><a href="#逐行读取" class="headerlink" title="逐行读取"></a>逐行读取</h1><p>还是原先的 pi.txt 文件，对文件对象使用 for 循环：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">filename = &apos;pi.txt&apos;</span><br><span class="line"></span><br><span class="line">with open(filename) as file_object:</span><br><span class="line">for line in file_object:</span><br><span class="line">	print(line)</span><br></pre></td></tr></table></figure></p>
<p>out：</p>
<pre><code>3.1415926535

  8979323846

  2643383279
</code></pre><p>会出现换行，是因为看不见的换行符也被读取进去了，然而 Python 自动在每行结束时添加换行符，相当于有两个换行符。可在 print 中添加：<br><code>print(line.rstrip())</code></p>
<p>这种方法挺常用，正常人类写的文件基本都换行。。。</p>
<h1 id="创建一个包含文件各行内容的列表"><a href="#创建一个包含文件各行内容的列表" class="headerlink" title="创建一个包含文件各行内容的列表"></a>创建一个包含文件各行内容的列表</h1><p>在上述代码中，open()返回的文件对象只在 with 代码块内可用。因为跳出 with 代码块后，文件自动关闭。<br>如果要在 with 代码块外访问文件的内容，可在 with 代码块内将文件的各行存储在一个列表中，并在 with 代码块外使用该列表。这时你可以立即处理文件的各个部分，也可推迟到程序后面再处理。</p>
<pre><code>with open(filename) as file_object:
    lines = file_object.readlines()

for line in lines:
    print(line.rstrip())
</code></pre><h1 id="使用文件内容"><a href="#使用文件内容" class="headerlink" title="使用文件内容"></a>使用文件内容</h1><p>操作上面的 pi.py 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with open(filename) as file_object:</span><br><span class="line">	lines = file_object.readlines()</span><br><span class="line"></span><br><span class="line">pi_string = &apos;&apos;</span><br><span class="line">for line in lines:</span><br><span class="line">	pi_string += line.rstrip()</span><br><span class="line"></span><br><span class="line">print(pi_string)</span><br><span class="line">print(len(pi_string))</span><br></pre></td></tr></table></figure></p>
<p>out：</p>
<pre><code>3.1415926535 8979323846 2643383279
36        #包含原来位于左边的两个空格共四个空格
</code></pre><h1 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h1><pre><code>filename = &apos;Python.txt&apos;

with open(filename, &apos;w&apos;) as file_object:
    file_object.write(&quot;I love Python.\n&quot;)    #将一个字符串写入文件中
</code></pre><p>补充：</p>
<ol>
<li>打开文件时，可指定读取模式（’r’）、 写入模式（’w’）、 附加模式（’a’）或让你能够读取和写入文件的模式（’r+’）。</li>
<li>如果你省略了模式实参， Python 将以默认的只读模式打开文件。</li>
<li>如果你要写入的文件不存在，函数 open() 将自动创建它。</li>
<li><strong>注意</strong>，如果指定文件已存在，而当前又是（’w’），Python 会自动清除原来的文件而新建文件。</li>
<li>Python 只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数 str() 将其转换为字符串格式。<br><strong>6. 方法 write() 不会在写入的文本末尾添加换行符。</strong></li>
</ol>
<h1 id="附加到文件"><a href="#附加到文件" class="headerlink" title="附加到文件"></a>附加到文件</h1><p><strong>附加模式：Python 不会在返回文件对象前清空文件，而写入到文件的行都将添加到文件末尾。如果指定的文件不存在， Python 将创建一个空文件。</strong></p>
<pre><code>filename = &apos;Python.txt&apos;

with open(filename, &apos;a&apos;) as file_object:
    file_object.write(&quot;I love creating new games.\n&quot;)
</code></pre><p>out：</p>
<pre><code>I love Python.
I love creating new games.
</code></pre><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>Python 使用被称为异常的特殊对象来管理程序执行期间发生的错误。<br>出现异常，程序也将继续运行，显示你编写的友好的错误消息，而不是令用户迷惑的 traceback。</p>
<p>以下是常见的异常。</p>
<h2 id="处理-ZeroDivisionError-异常（使用-try-except-代码块）"><a href="#处理-ZeroDivisionError-异常（使用-try-except-代码块）" class="headerlink" title="处理 ZeroDivisionError 异常（使用 try-except 代码块）"></a>处理 ZeroDivisionError 异常（使用 try-except 代码块）</h2><p>print(5/0)</p>
<p>如果这样写，系统会报错：<br><code>ZeroDivisionError: division by zero</code></p>
<p>我们可以这样：</p>
<pre><code>try:
    print(5/0)
except ZeroDivisionError:
    print(&quot;You can&apos;t divide by zero!&quot;)
</code></pre><p>out：</p>
<pre><code>You can&apos;t divide by zero!
</code></pre><p>如果try代码块中的代码运行起来没有问题， Python 将跳过 except 代码块；如果 try 代码块中的代码导致了错误， Python 将查找这样的 except 代码块，并运行其中的代码，即其中指定的错误与引发的错误相同。<br>此外，如果 try-except 代码块后面还有其他代码，程序将接着运行，因为已经告诉了 Python 如何处理这种错误。</p>
<p>崩溃后的处理方法：使用异常避免崩溃（ else 代码块）</p>
<p>我们可以做一个除法运算器：</p>
<pre><code>print(&quot;Give me two numbers, and I&apos;ll divide them.&quot;)
print(&quot;Enter &apos;q&apos; to quit.&quot;)

while True:
    first_number = input(&quot;\nFirst number: &quot;)

    if first_number == &apos;q&apos;:
        break

    second_number = input(&quot;Second number: &quot;)
    if second_number == &apos;q&apos;:
        break

    try:
        answer = int(first_number) / int(second_number)
    except ZeroDivisionError:
        print(&quot;You can&apos;t divide by 0!&quot;)
    else:
        print(answer)
</code></pre><h2 id="处理-FileNotFoundError-异常"><a href="#处理-FileNotFoundError-异常" class="headerlink" title="处理 FileNotFoundError 异常"></a>处理 FileNotFoundError 异常</h2><p>有种很常见的问题：找不到文件。<br>假设 ganru.txt 文件不存在：</p>
<pre><code>filename = &apos;ganru.txt&apos;

try:
    with open(filename) as f_obj:
        contents = f_obj.read()

except FileNotFoundError:
    print(&quot;Sorry, the file &quot; + filename + &quot; does not exist.&quot;)

else:
    ...
</code></pre><p>如果文件不存在，这个程序什么都不做，因此错误处理代码的意义不大。</p>
<h2 id="碰到异常啥都不干"><a href="#碰到异常啥都不干" class="headerlink" title="碰到异常啥都不干"></a>碰到异常啥都不干</h2><p>有时候碰到异常，只希望当作没事发生。可以这样做：<br>ex：</p>
<pre><code>except FileNotFoundError:
    pass
</code></pre><h1 id="分析文本"><a href="#分析文本" class="headerlink" title="分析文本"></a>分析文本</h1><p>split()：以空格为分隔符将字符串分拆成多个部分，并将这些部分都存储到一个列表中。</p>
<p>我们可以分析一个文本有多少个单词：</p>
<pre><code>filename = &apos;ganru.txt&apos;

try:
    with open(filename) as f_obj:
        contents = f_obj.read()

except FileNotFoundError:
    print(&quot;Sorry, the file &quot; + filename + &quot; does not exist.&quot;)

else:
    # 计算文件大致包含多少个单词
    words = contents.split()
    num_words = len(words)
    print(&quot;The file &quot; + filename + &quot; has about &quot; + str(num_words) + &quot; words.&quot;)
</code></pre><h1 id="对多文件分析"><a href="#对多文件分析" class="headerlink" title="对多文件分析"></a>对多文件分析</h1><p>不可能每次分析文件都写上述代码，效率太低，用函数来做：</p>
<pre><code>def count_words(filename):
    &quot;&quot;&quot;分析文件大致有多少个单词&quot;&quot;&quot;
    try:
        with open(filename) as f_obj:
            contents = f_obj.read()

    except FileNotFoundError:
        print(&quot;Sorry, the file &quot; + filename + &quot; does not exist.&quot;)

    else:
        # 计算文件大致包含多少个单词
        words = contents.split()
        num_words = len(words)
        print(&quot;The file &quot; + filename + &quot; has about &quot; + str(num_words) + &quot; words.&quot;)

filename = &apos;ganru.txt&apos;
count_words(filename)

文件太多的时候：

filenames = [&apos;ganru.txt&apos;, &apos;gandalf.txt&apos;, ...]
for file in filenames:
    count_words(filename)
</code></pre><h1 id="数据的存储与读取"><a href="#数据的存储与读取" class="headerlink" title="数据的存储与读取"></a>数据的存储与读取</h1><p>用到 JSON 模块来存储数据。（JSON 不是 Python 才有的，任何语言都可以使用它）</p>
<h2 id="json-dump-和-json-load-的使用"><a href="#json-dump-和-json-load-的使用" class="headerlink" title="json.dump()和 json.load() 的使用"></a>json.dump()和 json.load() 的使用</h2><p>json.dump()用于存储，json.load()用于读取。</p>
<p>演示一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import json		#用 json 模块要导入</span><br><span class="line"></span><br><span class="line">numbers = [2, 3, 5, 7, 11, 13]</span><br><span class="line"></span><br><span class="line">filename = &apos;numbers.json&apos;</span><br><span class="line">with open(filename, &apos;w&apos;) as f_obj:</span><br><span class="line">	json.dump(numbers, f_obj)	#将数字列表存储于 numbers.json 中</span><br></pre></td></tr></table></figure></p>
<p>这时候用记事本打开 numbers.json 文件，可以发现跟 numbers 列表一模一样。</p>
<p>读取：</p>
<pre><code>filename = &apos;numbers.json&apos;
with open(filename) as f_obj:
    numbers = json.load(f_obj)
</code></pre><p>out：</p>
<pre><code>[2, 3, 5, 7, 11, 13]
</code></pre><h2 id="保存和读取用户生成的数据"><a href="#保存和读取用户生成的数据" class="headerlink" title="保存和读取用户生成的数据"></a>保存和读取用户生成的数据</h2><p>保存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">username = input(&quot;What is your name? &quot;)</span><br><span class="line"></span><br><span class="line">filename = &apos;username.json&apos;</span><br><span class="line">with open(filename, &apos;w&apos;) as f_obj:</span><br><span class="line">	json.dump(username, f_obj)</span><br><span class="line">	print(&quot;We&apos;ll remember you when you come back, &quot; + username + &quot;!&quot;)</span><br></pre></td></tr></table></figure></p>
<p>读取：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">filename = &apos;username.json&apos;</span><br><span class="line"></span><br><span class="line">with open(filename) as f_obj:</span><br><span class="line">	username = json.load(f_obj)</span><br><span class="line">	print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</span><br></pre></td></tr></table></figure></p>
<p>也可以和 try-except 代码块一起用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line"># 如果以前存储了用户名，就加载它</span><br><span class="line"># 否则，就提示用户输入用户名并存储它</span><br><span class="line">filename = &apos;username.json&apos;</span><br><span class="line">try:</span><br><span class="line">	with open(filename) as f_obj:</span><br><span class="line">		username = json.load(f_obj)</span><br><span class="line"></span><br><span class="line">except FileNotFoundError:</span><br><span class="line">	username = input(&quot;What is your name? &quot;)</span><br><span class="line"></span><br><span class="line">	with open(filename, &apos;w&apos;) as f_obj:</span><br><span class="line">		json.dump(username, f_obj)</span><br><span class="line">		print(&quot;We&apos;ll remember you when you come back, &quot; + username + &quot;!&quot;)</span><br><span class="line"></span><br><span class="line">else:</span><br><span class="line">	print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</span><br></pre></td></tr></table></figure></p>
<h1 id="代码重构"><a href="#代码重构" class="headerlink" title="代码重构"></a>代码重构</h1><p>重构，即将将代码划分为一系列完成具体工作的函数。重构让代码更清晰、更易于理解、更容易扩展。<br>我们整合上述代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">def greet_user():</span><br><span class="line">	&quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;</span><br><span class="line">	filename = &apos;username.json&apos;</span><br><span class="line">	try:</span><br><span class="line">		with open(filename) as f_obj:</span><br><span class="line">			username = json.load(f_obj)</span><br><span class="line">	</span><br><span class="line">	except FileNotFoundError:</span><br><span class="line">		username = input(&quot;What is your name? &quot;)</span><br><span class="line">		with open(filename, &apos;w&apos;) as f_obj:</span><br><span class="line">			json.dump(username, f_obj)</span><br><span class="line">			print(&quot;We&apos;ll remember you when you come back, &quot; + username + &quot;!&quot;)</span><br><span class="line">	</span><br><span class="line">	else:</span><br><span class="line">		print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</span><br><span class="line"></span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure></p>
<p>可以看出， greet_user() 函数有点杂，不太好看。我们可以重构它，让它不用执行这么多任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">import json</span><br><span class="line"></span><br><span class="line">def get_stored_username():</span><br><span class="line">	&quot;&quot;&quot;如果存储了用户名，就获取它&quot;&quot;&quot;</span><br><span class="line">	filename = &apos;username.json&apos;</span><br><span class="line">	</span><br><span class="line">	try:</span><br><span class="line">		with open(filename) as f_obj:</span><br><span class="line">			username = json.load(f_obj)</span><br><span class="line">	</span><br><span class="line">	except FileNotFoundError:</span><br><span class="line">		return None</span><br><span class="line">	</span><br><span class="line">	else:</span><br><span class="line">		return username</span><br><span class="line"></span><br><span class="line">def get_new_username():</span><br><span class="line">	&quot;&quot;&quot;提示用户输入用户名&quot;&quot;&quot;</span><br><span class="line">	username = input(&quot;What is your name? &quot;)</span><br><span class="line">	filename = &apos;username.json&apos;</span><br><span class="line">	</span><br><span class="line">	with open(filename, &apos;w&apos;) as f_obj:</span><br><span class="line">		json.dump(username, f_obj)</span><br><span class="line">	</span><br><span class="line">	return username</span><br><span class="line"></span><br><span class="line">def greet_user():</span><br><span class="line">	&quot;&quot;&quot;问候用户，并指出其名字&quot;&quot;&quot;</span><br><span class="line">	username = get_stored_username()</span><br><span class="line">	</span><br><span class="line">	if username:</span><br><span class="line">		print(&quot;Welcome back, &quot; + username + &quot;!&quot;)</span><br><span class="line">	else:</span><br><span class="line">		username = get_new_username()</span><br><span class="line">		print(&quot;We&apos;ll remember you when you come back, &quot; + username + &quot;!&quot;)</span><br><span class="line">		</span><br><span class="line">greet_user()</span><br></pre></td></tr></table></figure></p>
<p>好像看起来代码更长了点。。<br>但是这样做让我们的目标更明确了，而且也很容易明白代码的运作。</p>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><pre><code>1. 文件的读取与使用
2. 文件的写入与附加模式（加内容到文件末尾）
3. 异常处理
4. 文本分析与多文本分析
5. 数据的存储与读取
6. 代码重构
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/2018/09/24/类（面向对象编程）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/ganru.github.io/2018/09/24/类（面向对象编程）/" itemprop="url">类（面向对象编程）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-24T17:18:18+08:00">
                2018-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Python笔记/" itemprop="url" rel="index">
                    <span itemprop="name">Python笔记</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong><p>写在前面</p></strong></p>
<hr>
<blockquote>
<p>该笔记学习的内容均来自于《Python 编程：从入门到实践》，只是作为一个内容总纲，若需详细学习，可去百度网盘<a href="https://pan.baidu.com/share/init?surl=dFxjtXf" target="_blank" rel="noopener">下载</a> ，密码：7rup</p>
</blockquote>
<h1 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h1><p>可以理解为 C 中的结构体，两者有点像，但又有不同。<br>根据类来创建对象被称为实例化，这让你能够使用类的实例。</p>
<h1 id="类的创建与使用"><a href="#类的创建与使用" class="headerlink" title="类的创建与使用"></a>类的创建与使用</h1><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><p>创建一个学生类，赋予每个学生其学习（study()）和睡觉（sleep()）的能力。</p>
<p>ex：</p>
<pre><code>class Student():    #首字母要大写，指的是类（约定的），括号空，是因为要从空白建立类
    &quot;&quot;&quot;学生类的模拟&quot;&quot;&quot;

    def \_\_init\_\_(self, name, age):    
    #注意这里有个坑，默认方法构造书写格式是__init__，而不是_init_，即在init两侧都是双下划线，不是单下划线。 
        &quot;&quot;&quot;初始化学生属性&quot;&quot;&quot;
        self.name = name
        self.age = age

    def study(self):
        &quot;&quot;&quot;模拟学生学习&quot;&quot;&quot;
        print(self.name.title() + &quot; is now learning.&quot;)

    def sleep(self):
        &quot;&quot;&quot;模拟学生睡觉&quot;&quot;&quot;
        print(self.name.title() + &quot; is now sleeping.&quot;)

    def get_descriptive(self):
        &quot;&quot;&quot;返回学生信息&quot;&quot;&quot;
        descriptive = self.name + &apos; &apos; + str(self.age)
        return descriptive.title()
</code></pre><ol>
<li>上述代码中，在类中出现的函数称为方法，如 3 个 def，与函数一样，只是名称发生了变化。</li>
<li>在类中，每当使用者用 Student 类创建新实例时，Python 就会自动运行方法 __init__()。每次写类都要初始化。</li>
<li>方法也有不同，方法名首尾都有下划线的一般指 <strong>默认方法</strong>，这是为了避免Python默认方法与普通方法发生名称冲突。</li>
<li>在 <em>init</em>() 中 self 必不可少，Python 调用这个方法来创建 Student 实例时，将自动传入实参 self。</li>
<li>每个与类相关联的方法调用都自动传递实参 self，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</li>
<li>可通过实例访问的变量成为 属性（如：name、age）。</li>
<li>每次新建实例时，只需写后面两个形参值。</li>
<li>另外两个方法，由于不需要额外的信息，故只有一个形参 self。</li>
<li>虽然没有写显式 return 语句，但 Python 会自动返回一个表示该学生的实例。</li>
</ol>
<h2 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h2><pre><code>class Student():
    --snip--

student_0 = Student(&apos;ganru&apos;, 20)

print(&quot;student_0&apos;s name is &quot; + student_0.name.title() + &quot;.&quot;)
print(&quot;student_0 is &quot; + str(student_0.age) + &quot; years old.&quot;)
student_0.study()
student_0.sleep()
print(student_0.get_descriptive())
</code></pre><p>out：</p>
<pre><code>student_0&apos;s name is Ganru.
student_0 is 20 years old.
Ganru is now learning.
Ganru is now sleeping.
</code></pre><h1 id="给属性指定默认值"><a href="#给属性指定默认值" class="headerlink" title="给属性指定默认值"></a>给属性指定默认值</h1><p>还是原来的 Student() 类，我们指定学生学校默认为 JYU：</p>
<pre><code>class Student():
    &quot;&quot;&quot;学生类的模拟&quot;&quot;&quot;

    def _init_(self, name, age):    
        &quot;&quot;&quot;初始化学生属性&quot;&quot;&quot;
        self.name = name
        self.age = age
        self.school = &apos;JYU&apos;        #改动在这里

    def study(self):
        --snip--

    def sleep(self):
        --snip--

    def get_descriptive(self):
        --snip--

    def original_school(self):
        &quot;&quot;&quot;打印一条学生原来学校的消息&quot;&quot;&quot;
        print(&quot;The student from &quot; + self.school)

student_0 = Student(&apos;ganru&apos;, 20)
print(student_0.get_descriptive())
student_0.original_school()
</code></pre><h1 id="属性值的修改"><a href="#属性值的修改" class="headerlink" title="属性值的修改"></a>属性值的修改</h1><h2 id="直接修改"><a href="#直接修改" class="headerlink" title="直接修改"></a>直接修改</h2><pre><code>class Student():
    --snip--

student_0 = Student(&apos;ganru&apos;, 20)
print(student_0.get_descriptive())
student_0.school = &apos;THU&apos;    #改动在这里
student_0.original_school()
</code></pre><h2 id="通过方法修改属性的值"><a href="#通过方法修改属性的值" class="headerlink" title="通过方法修改属性的值"></a>通过方法修改属性的值</h2><p>若想无需直接访问属性，可将值传递给一个方法，由它在内部进行更新。<br>在原先类 Student() 的基础上，加上：<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def update_school(self, value):</span><br><span class="line">	&quot;&quot;&quot;将学校名称改为指定值&quot;&quot;&quot;</span><br><span class="line">	self.school = value</span><br></pre></td></tr></table></figure></p>
<pre><code>student_0 = Student(&apos;ganru&apos;, 20)
print(student_0.get_descriptive())

student_0.update_school(&apos;PKU&apos;)    #改动在这里
student_0.original_school()
</code></pre><p>还可以加一些功能，比如禁止属性值回调。<br>可参考书（P145）中的 <strong>里程表读数回调</strong>：</p>
<pre><code>class Car():
    --snip--

    def update_odometer(self, mileage):
        &quot;&quot;&quot;
        将里程表读数设置为指定的值
        禁止将里程表读数往回调
        &quot;&quot;&quot;
        if mileage &gt;= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print(&quot;You can&apos;t roll back an odometer!&quot;)
</code></pre><h2 id="通过方法对属性的值进行递增"><a href="#通过方法对属性的值进行递增" class="headerlink" title="通过方法对属性的值进行递增"></a>通过方法对属性的值进行递增</h2><p>比如上面的 Car 类，可以加一个 def：</p>
<pre><code>def increment_odometer(self, miles):
    &quot;&quot;&quot;将里程表读数在原来的基础上增加指定的量&quot;&quot;&quot;
    self.odometer_reading += miles
</code></pre><h1 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h1><p>有时候懒得写多几个重复项，想引用其他类并自定义自己的类，可用继承。原有类称父类，新类称子类。</p>
<p>父类：</p>
<pre><code>class Car():
    &quot;&quot;&quot;一次模拟汽车的简单尝试&quot;&quot;&quot;
    def __init__(self, make, model, year):
        self.make = make
        self.model = model
        self.year = year
        self.odometer_reading = 0

    def get_descriptive_name(self):
        long_name = str(self.year) + &apos; &apos; + self.make + &apos; &apos; + self.model
        return long_name.title()

    def read_odometer(self):
        print(&quot;This car has &quot; + str(self.odometer_reading) + &quot; miles on it.&quot;)

    def update_odometer(self, mileage):
        if mileage &gt;= self.odometer_reading:
            self.odometer_reading = mileage
        else:
            print(&quot;You can&apos;t roll back an odometer!&quot;)

    def increment_odometer(self, miles):
        self.odometer_reading += miles
</code></pre><p>子类：</p>
<pre><code>class ElectricCar(Car):        #类括号内若导入参数，则继承某一个类
    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;

    def __init__(self, make, model, year):
        &quot;&quot;&quot;初始化父类的属性&quot;&quot;&quot;
        super().__init__(make, model, year)        
        #super 是一个特殊函数，让 Python 调用 ElectricCar 的父类的方法 __init__()，让 ElectricCar 实例包含父类的所有属性。


my_tesla = ElectricCar(&apos;tesla&apos;, &apos;model s&apos;, 2016)
print(my_tesla.get_descriptive_name())
</code></pre><p>out：</p>
<pre><code>2016 Tesla Model S
</code></pre><ol>
<li>父类和子类必须要在同一文件中，且父类在子类前面。</li>
<li>父类也称超类，名称 super 因此而得名。</li>
</ol>
<h1 id="给子类定义属性和方法"><a href="#给子类定义属性和方法" class="headerlink" title="给子类定义属性和方法"></a>给子类定义属性和方法</h1><pre><code>class Car():
    --snip--

class ElectricCar(Car):
    &quot;&quot;&quot;Represent aspects of a car, specific to electric vehicles.&quot;&quot;&quot;

    def __init__(self, make, model, year):
        &quot;&quot;&quot;
        电动汽车的独特之处
        初始化父类的属性，再初始化电动汽车特有的属性
        &quot;&quot;&quot;
        super().__init__(make, model, year)
        self.battery_size = 70                #子类属性添加

    def describe_battery(self):
        &quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;
        print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)

my_tesla = ElectricCar(&apos;tesla&apos;, &apos;model s&apos;, 2016)
print(my_tesla.get_descriptive_name())
my_tesla.describe_battery()
</code></pre><p>out：</p>
<pre><code>2016 Tesla Model S
This car has a 70-kWh battery.
</code></pre><ol>
<li>如果一个属性或方法是任何汽车都有的，而不是电动汽车特有的，就应将其加入到 Car 类而不是 ElectricCar 类中。</li>
<li>这样，使用 Car 类的人将获得相应的功能，而 ElectricCar 类只包含处理电动汽车特有属性和行为的代码。</li>
</ol>
<h1 id="重写父类"><a href="#重写父类" class="headerlink" title="重写父类"></a>重写父类</h1><p>假设 Car 类有一个名为 fill_gas_tank() 的方法，它对全电动汽车来说毫无意义，这时我们可以重写它：</p>
<pre><code>def ElectricCar(Car):
    --snip--

    def fill_gas_tank():
        &quot;&quot;&quot;电动汽车没有油箱&quot;&quot;&quot;
        print(&quot;This car doesn&apos;t need a gas tank!&quot;)
</code></pre><p>这时候，如果我们再次调用方法 fill_gas_tank()，则 Python 不会使用父类的方法，而是我们在子类新写的方法。</p>
<h1 id="将实例用作属性（属性中的属性或方法）"><a href="#将实例用作属性（属性中的属性或方法）" class="headerlink" title="将实例用作属性（属性中的属性或方法）"></a>将实例用作属性（属性中的属性或方法）</h1><p>有时候类太大，可能会比较复杂，可以将大类拆分成小类。</p>
<pre><code>class Car():
    --snip--


<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Battery():</span><br><span class="line">	&quot;&quot;&quot;一次模拟电动汽车电瓶的简单尝试&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">	def __init__(self, battery_size=70):</span><br><span class="line">		&quot;&quot;&quot;初始化电瓶的属性&quot;&quot;&quot;</span><br><span class="line">		self.battery_size = battery_size</span><br><span class="line"></span><br><span class="line">	def describe_battery(self):</span><br><span class="line">		&quot;&quot;&quot;打印一条描述电瓶容量的消息&quot;&quot;&quot;</span><br><span class="line">		print(&quot;This car has a &quot; + str(self.battery_size) + &quot;-kWh battery.&quot;)</span><br></pre></td></tr></table></figure>

class ElectricCar(Car):
    &quot;&quot;&quot;电动汽车的独特之处&quot;&quot;&quot;

    def __init__(self, make, model, year):
        &quot;&quot;&quot;
        初始化父类的属性，再初始化电动汽车特有的属性
        &quot;&quot;&quot;
        super().__init__(make, model, year)
        self.battery = Battery()        #将实例用作属性

my_tesla = ElectricCar(&apos;tesla&apos;, &apos;model s&apos;, 2016)
print(my_tesla.get_descriptive_name())
my_tesla.battery.describe_battery()
</code></pre><p>out：</p>
<pre><code>2016 Tesla Model S
This car has a 70-kWh battery.
</code></pre><h1 id="类的导入"><a href="#类的导入" class="headerlink" title="类的导入"></a>类的导入</h1><p>跟函数模块差不多，将类写入一个 .py 文件。<br>导入格式：</p>
<p>import module_name（.py 文件名）<br>from module_name（.py 文件名） import class_name（在 .py 文件中的类名）<br>from module_name import class_0, class_1, …</p>
<p>如果模块与模块之间有联系，则这两个模块都要导入同一个文件中，不然创建实例时将引发错误。</p>
<h1 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h1><p>Python标准库是一组模块，安装的Python都包含它。大致理解类之后，就可以使用他人的模块了。</p>
<p>尝试：<br>如果在以前，我们可能这么写：favorite_languages = {}<br>字典能够将信息关联起来，但不记录添加键—值对的顺序。要创建字典并记录其添加顺序，可使用模块 collections 中的 OrderedDict 类。</p>
<pre><code>from collections import OrderedDict

favorite_languages = OrderedDict()

favorite_languages[&apos;jen&apos;] = &apos;python&apos;
favorite_languages[&apos;sarah&apos;] = &apos;c&apos;
favorite_languages[&apos;edward&apos;] = &apos;ruby&apos;
favorite_languages[&apos;phil&apos;] = &apos;python&apos;

for name, language in favorite_languages.items():
    print(name.title() + &quot;&apos;s favorite language is &quot; +
        language.title() + &quot;.&quot;)
</code></pre><p>out：</p>
<pre><code>Jen&apos;s favorite language is Python.
Sarah&apos;s favorite language is C.
Edward&apos;s favorite language is Ruby.
Phil&apos;s favorite language is Python.
</code></pre><h1 id="类编码风格"><a href="#类编码风格" class="headerlink" title="类编码风格"></a>类编码风格</h1><ol>
<li><p>驼峰命名法：类名中的每个单词的首字母都大写，而不使用下划线。<br>ex：<br>class Car():<br>class Student():<br>…</p>
</li>
<li><p>实例名和模块名都采用小写格式，并在单词之间加上下划线。<br>ex：<br>my_tesla<br>student_0<br>son.py<br>…</p>
</li>
<li><p>对于每个类，都写类注释。</p>
</li>
<li>在类中，可使用一个空行来分隔方法；而在模块中，可使用两个空行来分隔类。</li>
<li>需要同时导入标准库中的模块和你编写的模块时，先编写导入标准库模块的 import 语句，再添加一个空行，然后编写导入你自己编写的模块的 import 语句。</li>
</ol>
<h1 id="学习要点"><a href="#学习要点" class="headerlink" title="学习要点"></a>学习要点</h1><ol>
<li>类的创建于使用（类的建立一定要初始化）</li>
<li>实例属性的修改</li>
<li>类的继承</li>
<li>重写父类</li>
<li>将实例用作属性（属性中的属性或方法）</li>
<li>类的导入</li>
<li>类编码的规约</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/ganru.github.io/page/2/">2</a><a class="extend next" rel="next" href="/ganru.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Ganru</p>
              <p class="site-description motion-element" itemprop="description">学习一向都是孤独的，慢慢玩。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/ganru.github.io/archives/">
              
                  <span class="site-state-item-count">19</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ganru</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/ganru.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/ganru.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/ganru.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/ganru.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/ganru.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/ganru.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
