<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/ganru.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/ganru.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/ganru.github.io/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/ganru.github.io/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/ganru.github.io/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/ganru.github.io/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/ganru.github.io/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="学习笔记," />










<meta name="description" content="Java 中接口与抽象类的区别？抽象类：  class 之前要有 abstract 关键字修饰。 只能被一个类单继承，即一个类只能使用一次继承关系。且这个子类必须实现该抽象类所有的抽象方法，要不就用 abstract 修饰这个子类。 里面没有具体方法，只有抽象方法。故它不能用来创建对象。 抽象方法必须声明为 public 或 protected，默认情况下是 public。  接口：  是一种极度">
<meta name="keywords" content="学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="Java大杂烩">
<meta property="og:url" content="https://ganru.github.io/posts/Java/2019-01-23-Java大杂烩.html">
<meta property="og:site_name" content="小黑屋">
<meta property="og:description" content="Java 中接口与抽象类的区别？抽象类：  class 之前要有 abstract 关键字修饰。 只能被一个类单继承，即一个类只能使用一次继承关系。且这个子类必须实现该抽象类所有的抽象方法，要不就用 abstract 修饰这个子类。 里面没有具体方法，只有抽象方法。故它不能用来创建对象。 抽象方法必须声明为 public 或 protected，默认情况下是 public。  接口：  是一种极度">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-02-17T12:46:53.068Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java大杂烩">
<meta name="twitter:description" content="Java 中接口与抽象类的区别？抽象类：  class 之前要有 abstract 关键字修饰。 只能被一个类单继承，即一个类只能使用一次继承关系。且这个子类必须实现该抽象类所有的抽象方法，要不就用 abstract 修饰这个子类。 里面没有具体方法，只有抽象方法。故它不能用来创建对象。 抽象方法必须声明为 public 或 protected，默认情况下是 public。  接口：  是一种极度">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/ganru.github.io/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://ganru.github.io/posts/Java/2019-01-23-Java大杂烩.html"/>





  <title>Java大杂烩 | 小黑屋</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/ganru.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">小黑屋</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/ganru.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/ganru.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-essay">
          <a href="/ganru.github.io/categories/随笔" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-terminal"></i> <br />
            
            随笔
          </a>
        </li>
      
        
        <li class="menu-item menu-item-write">
          <a href="/ganru.github.io/categories/写作" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-edit"></i> <br />
            
            写作
          </a>
        </li>
      
        
        <li class="menu-item menu-item-read">
          <a href="/ganru.github.io/categories/阅读" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-book"></i> <br />
            
            阅读
          </a>
        </li>
      
        
        <li class="menu-item menu-item-study">
          <a href="/ganru.github.io/categories/学习" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-bookmark"></i> <br />
            
            学习
          </a>
        </li>
      
        
        <li class="menu-item menu-item-java">
          <a href="/ganru.github.io/categories/Java" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-coffee"></i> <br />
            
            Java
          </a>
        </li>
      
        
        <li class="menu-item menu-item-py_code">
          <a href="/ganru.github.io/categories/Python笔记" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-codiepie"></i> <br />
            
            Python
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://ganru.github.io/ganru.github.io/posts/Java/2019-01-23-Java大杂烩.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Ganru">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/ganru.github.io/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小黑屋">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Java大杂烩</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-23T16:37:09+08:00">
                2019-01-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/ganru.github.io/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java-中接口与抽象类的区别？"><a href="#Java-中接口与抽象类的区别？" class="headerlink" title="Java 中接口与抽象类的区别？"></a>Java 中接口与抽象类的区别？</h1><p>抽象类：</p>
<ol>
<li>class 之前要有 abstract 关键字修饰。</li>
<li>只能被一个类单继承，即一个类只能使用一次继承关系。且这个子类必须实现该抽象类所有的抽象方法，要不就用 abstract 修饰这个子类。</li>
<li>里面没有具体方法，只有抽象方法。故它不能用来创建对象。</li>
<li>抽象方法必须声明为 public 或 protected，默认情况下是 public。</li>
</ol>
<p>接口：</p>
<ol>
<li>是一种极度抽象的类，其中的变量会隐式指定为 public static final ，而方法会隐式指定为 public abstract。</li>
<li>一个类可以拥有多个接口。</li>
<li>可以有默认方法，静态方法不被子类实现。</li>
</ol>
<p>两者区别：</p>
<ol>
<li>抽象类只能被一个类单一继承，而多个接口可以被单一类实现。</li>
<li>抽象类中可以拥有自己的数据成员（要加 abstract 关键字），也可以有非 abstract 的成员方法（方便子类继承，不用重写）。而接口的变量成员必须是 static final 的（但是我们一般不在接口中定义数据成员），此外所有的成员方法都是 abstract 。</li>
<li>继承抽象类，要么实现抽象类中的所有的抽象方法，要么该类必须声明为 abstract 类。然而实现接口，则是必须实现所有的抽象方法。</li>
<li>接口变量默认为 public static final 类型，且必须有初值。</li>
<li>在 Java1.8 之后，接口多了 static、default 实现，这些不属于实例，属于类方法。其中 static 不允许子类覆盖，而抽象类允许有 static 方法。</li>
</ol>
<h1 id="Java-对象创建的过程？"><a href="#Java-对象创建的过程？" class="headerlink" title="Java 对象创建的过程？"></a>Java 对象创建的过程？</h1><ol>
<li>首先判断类是否加载</li>
<li>然后为其分配内存<br><strong>指针碰撞：</strong>假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那么分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。<br><strong>空闲列表：</strong>如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</li>
<li>初始化零值</li>
<li>设置对象头<br>虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在对象的对象头之中。</li>
<li>执行 &lt;init> 方法<br>从 JVM 视角来看，对象已建立好，但是在 Java 视角来看，所有字段都还只是零，需要执行一遍 init 方法，把对象按照程序员的意愿进行初始化。</li>
</ol>
<p>小注：对象在内存中的存储布局可以分为：对象头、实例数据，对齐填充。对象的定位访问有：句柄和直接访问。</p>
<h1 id="Java-重载与重写的区别？"><a href="#Java-重载与重写的区别？" class="headerlink" title="Java 重载与重写的区别？"></a>Java 重载与重写的区别？</h1><h2 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h2><p>重载是让类以统一的方式处理不同类型数据的一种手段。大白话讲就是一个类中有多种名称相同的方法，但它们的方法体内容不同，或者参数类型和个数不同。是一个类中多态性的一种表现。<br>此外重载由静态类型确定，即在类加载时确定，属静态分派。</p>
<h2 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h2><p>重写，也称覆盖。多出现在子类继承中，父类与子类之间的多态性，对父类的函数进行重新定义。也就是说父类有些已经写好的方法，但是子类不想原封不动地继承，这时候可以 @Override 重写一个与父类方法名称相同的方法。<br>重写由动态类型确定，是在运行时确定的，属于动态分派。动态分派由虚方法表实现，虚方法表中存在各个方法的实际入口地址，若父类方法没有被重写，则子类父类方法表中的方法地址相同，否则子类方法表的地址指向重写后的地址。</p>
<h1 id="init-方法和-clinit-方法"><a href="#init-方法和-clinit-方法" class="headerlink" title="init 方法和 clinit 方法"></a>init 方法和 clinit 方法</h1><p>Java 在编译后会在字节码文件中生成 init 方法，称为 <strong>实例构造器</strong>。这个会将语句块、变量初始化、调用父类的构造器等等操作收敛到 init 方法中。它的收敛顺序为：</p>
<ol>
<li>父类变量初始化</li>
<li>父类语句块</li>
<li>父类构造函数</li>
<li>子类变量初始化</li>
<li>子类语句块</li>
<li>子类构造函数</li>
</ol>
<p>不仅仅会在字节码中生成 init 方法，而且还会生成 clinit 方法，称为 <strong>类构造器</strong>。功能大抵与实力构造器相同，不同的是 clinit 处理的对象是静态成员。收敛顺序为：</p>
<ol>
<li>父类静态变量初始化</li>
<li>父类静态语句块</li>
<li>子类静态变量初始化</li>
<li>子类静态语句块</li>
</ol>
<p>此外如果父类是接口，不会调用 &lt;clinit> 方法。一个类可以没有 clinit 方法。</p>
<p>clinit 方法在类加载时执行，init 在对象实例化时执行，故，clinit 方法一定先于 init 方法。</p>
<h1 id="Java-中的引用"><a href="#Java-中的引用" class="headerlink" title="Java 中的引用"></a>Java 中的引用</h1><p>分为四类：强引用、软引用、弱引用、虚引用。<br><strong>强引用：</strong>就是我们常见的<code>Object object = new object();</code>这样的。只要强引用还存在，那么永远不会被垃圾回收器回收掉这个对象，它可以存活到 JVM 停止运行的时候。</p>
<p><strong>软引用：</strong>用来描述一些还有点用，但是非必须的对象。软引用是使用 SoftReference 创建的引用，强度弱于强引用，被其引用的对象在内存不足的时候会被回收，不会产生内存溢出。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 创建强引用与String对象关联，现在该 String 对象为强可达状态</span><br><span class="line">String s = new String(&quot;Frank&quot;);</span><br><span class="line">// 再创建一个软引用关联该对象</span><br><span class="line">SoftReference&lt;String&gt; softRef = new SoftReference&lt;String&gt;(s);</span><br><span class="line"></span><br><span class="line">s = null;	// 消除强引用，现在只剩下软引用与其关联，该 String 对象为软可达状态</span><br><span class="line">s = softRef.get();</span><br><span class="line">// 重新关联上强引用，此时如果 GC 没有回收 String 对象，则 s 继续与之强关联，</span><br><span class="line">//否则 s 只会关联到 null 值。</span><br></pre></td></tr></table></figure>
<p>根据代码大概可以看出，软引用就是间接通过强引用对象对目标对象（String）关联而得到的对象类群。如果内存即将发生溢出，在此之前会把这类对象进行二次垃圾回收，如果这次回收还是没有解决内存溢出，就会发生异常。软引用可以用来实现内存敏感的高速缓存。比如网页缓存、图片缓存等。</p>
<p><strong>弱引用：</strong>描述非必需对象。长这样：<br><code>WeakReference&lt;String&gt; abcWeakRef = new WeakReference&lt;String&gt;(str);</code><br>弱引用有着比软引用更脆弱的生命周期。即使内存充足，但是只要被 GC 扫描到就会被回收。不过由于垃圾收集器线程的优先级很低，所以弱引用不一定会被很快回收。</p>
<p><strong>虚引用：</strong>无法通过一个虚引用获得一个对象实例，一个对象是否有虚引用，对其生命周期无影响。它存在的目的是对象在被垃圾回收时收到一个系统通知，而且它跟软、弱引用有个区别，就是必须和引用队列 (ReferenceQueue) 联合使用。</p>
<h1 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h1><p>首先要明白，可达性分析是用于判断对象是否存活的算法。</p>
<p>起始，有一系列的 GC Root 根节点，从这些节点向下搜索，走过的路径称为引用链。如果有这么一条链（注意不是引用链，或者单一对象）向上无法追溯到 GC Root 根节点，则该链上的对象都为不可达状态，可以被回收。<strong>但是可以用 finallize() 方法自救</strong>。<br>有哪些可以作为 GC Root 对象：</p>
<ol>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>虚拟机栈中引用的对象</li>
<li>本地方法中引用的对象<br>题外话：其实判断对象是否存活还有一种古老且报废的方法：<strong>引用计数法</strong>。在堆中存储对象时，在对象头处维护一个 counter 计数器，如果一个对象增加了一个引用与之相连，则将 counter++ 。如果一个引用关系失效则 counter– 。如果一个对象的 counter 变为 0 ，则说明该对象已经被废弃，不处于存活状态。<strong>但是</strong>，有这么一种情况，如果对象 A 持有对象 B ，而 B 也持有 A ，那就会发生类似操作系统中死锁的循环持有，A 与 B 的 counter 恒大于 1 ，会使得 GC 永远无法回收这两个对象。</li>
</ol>
<h1 id="String-是基本数据类型吗？"><a href="#String-是基本数据类型吗？" class="headerlink" title="String 是基本数据类型吗？"></a>String 是基本数据类型吗？</h1><p>不是，基本数据类型只有 8 个：int、short、long、byte、double、float、char、boolean。</p>
<h1 id="Java-中-Object-类有哪些常用方法？有什么作用？"><a href="#Java-中-Object-类有哪些常用方法？有什么作用？" class="headerlink" title="Java 中 Object 类有哪些常用方法？有什么作用？"></a>Java 中 Object 类有哪些常用方法？有什么作用？</h1><p>toString(): 用于输出该对象的字符串表示形式。<br>getclass(): final 方法，获得运行时类型。<br>finalize(): 释放资源，用的少。<br>equals(): 判断两对象中的内容是否相等。<br>hashCode(): 用于哈希查找。<br>wait(): wait方法就是使当前线程等待该对象的锁。<br>notify(): 唤醒在该对象上在等待的某个线程。</p>
<h1 id="哪个类声明了-clone-方法？是-Cloneable-还是-Object？"><a href="#哪个类声明了-clone-方法？是-Cloneable-还是-Object？" class="headerlink" title="哪个类声明了 clone 方法？是 Cloneable 还是 Object？"></a>哪个类声明了 clone 方法？是 Cloneable 还是 Object？</h1><p>java.lang.Cloneable 是一个标示性接口，不包含任何方法，clone 方法在 object 类中定义。并且需要知道 clone() 方法是一个本地方法，这意味着它是由 c 或 c++ 或 其他本地语言实现的。</p>
<h1 id="Java-中-操作符是线程安全的吗？"><a href="#Java-中-操作符是线程安全的吗？" class="headerlink" title="Java 中 ++ 操作符是线程安全的吗？"></a>Java 中 ++ 操作符是线程安全的吗？</h1><p>不安全，这个操作符涉及到多个指令，比如赋值，增加，存储回内存，会有线程交叉现象。</p>
<h1 id="基本数据类型和引用类型的区别在哪里？"><a href="#基本数据类型和引用类型的区别在哪里？" class="headerlink" title="基本数据类型和引用类型的区别在哪里？"></a>基本数据类型和引用类型的区别在哪里？</h1><ol>
<li>基本数据类型变量指向的是具体的数值，而引用类型变量指向的是堆内存里存数据对象的内存地址，即变量名指向 hash 值。</li>
<li>基本数据类型之间的赋值是创建新的拷贝，而引用类型之间的赋值只是传递引用。</li>
<li>“==”和“!=”在基本数据类型中是在比较值，而在引用类型中是在比较两个引用是否相同，想比较值需要自己实现equals()方法。</li>
<li>基本数据类型是在栈中进行分配，而引用类型是在堆中进行分配。</li>
<li>前者变量在声明之后 java 就会立刻分配给他内存空间，后者它以特殊的方式(类似 C 指针)指向对象实体（具体的值），这类变量声明时不会分配内存，只是存储了一个内存地址。</li>
<li>基本类型变量创建和销毁很快，而类对象需要 JVM 去销毁。</li>
</ol>
<h1 id="String-类可以继承吗？"><a href="#String-类可以继承吗？" class="headerlink" title="String 类可以继承吗？"></a>String 类可以继承吗？</h1><p>不能，String 类是 final 的。</p>
<h1 id="final-有什么使用场景？"><a href="#final-有什么使用场景？" class="headerlink" title="final 有什么使用场景？"></a>final 有什么使用场景？</h1><ol>
<li>final 类不能被继承</li>
<li>final 变量不能被改变</li>
<li>final 方法不能被重写</li>
</ol>
<h1 id="Java-中-String，StringBuilder，StringBuffer-的区别"><a href="#Java-中-String，StringBuilder，StringBuffer-的区别" class="headerlink" title="Java 中 String，StringBuilder，StringBuffer 的区别"></a>Java 中 String，StringBuilder，StringBuffer 的区别</h1><p>String 不可变，StringBuffer 和 StringBuilder 可变，此外，String 和 StringBuffer 是线程安全的。</p>
<h1 id="Java-中-char-是多少个-bit-？-可以存储中文吗？"><a href="#Java-中-char-是多少个-bit-？-可以存储中文吗？" class="headerlink" title="Java 中 char 是多少个 bit ？ 可以存储中文吗？"></a>Java 中 char 是多少个 bit ？ 可以存储中文吗？</h1><p>char 是 16-bit 的 Unicode 字符，可以存储中文。</p>
<h1 id="构造器（constructor）是否可被重写（override）？"><a href="#构造器（constructor）是否可被重写（override）？" class="headerlink" title="构造器（constructor）是否可被重写（override）？"></a>构造器（constructor）是否可被重写（override）？</h1><p>不能，它不能被继承，自然不能被重写，但是可以重载。<br>题外：它是你所理解的构造方法。构造函数也叫做构造方法、构造器，英文叫做 Constructor …</p>
<h1 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别?"></a>成员变量和局部变量的区别?</h1><ol>
<li>成员变量定义在类中，局部变量定义在方法、参数、语句块中。</li>
<li>成员变量在整个类中都有效，局部变量不能离开它所属的大括号被其他作用域应用。</li>
<li>成员变量存在于堆内存中，与对象共存亡。局部变量跟着方法等这些所属的区域运行而存在，结束后释放。</li>
</ol>
<h1 id="列举-3-4-个集合实现类"><a href="#列举-3-4-个集合实现类" class="headerlink" title="列举 3-4 个集合实现类"></a>列举 3-4 个集合实现类</h1><p>ArrayList、HashMap、LinkedList、HashSet。</p>
<h1 id="Java-中哪些集合类是线程安全的？哪些集合类是线程不安全的？（各列举至少4个，不许说错）"><a href="#Java-中哪些集合类是线程安全的？哪些集合类是线程不安全的？（各列举至少4个，不许说错）" class="headerlink" title="Java 中哪些集合类是线程安全的？哪些集合类是线程不安全的？（各列举至少4个，不许说错）"></a>Java 中哪些集合类是线程安全的？哪些集合类是线程不安全的？（各列举至少4个，不许说错）</h1><p>安全的：Vector、HashTable、Properties、Concurrent开头的类（如ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet、ConcurrentLinkedQueue、ConcurrentLinkedDeque）、CopyOnWrite开头的类（如CopyOnWriteArrayList、CopyOnWriteArraySet）等。</p>
<p>不安全的：ArrayList、LinkedList、HashSet、TreeSet、HashMap、TreeMap 等。</p>
<h1 id="Java-中-ArrayList-与-LinkedList-实现上的不同-各自试用的场景？"><a href="#Java-中-ArrayList-与-LinkedList-实现上的不同-各自试用的场景？" class="headerlink" title="Java 中 ArrayList 与 LinkedList 实现上的不同? 各自试用的场景？"></a>Java 中 ArrayList 与 LinkedList 实现上的不同? 各自试用的场景？</h1><p>ArrayList 是可变数组，基于数组的数据结构。一般用于随机访问 get、set 这些（查找），因为数组是通过下标访问的。<br>LinkedList 是基于链表的数据结构。一般用于插入、删除操作，方便，而 ArrayList 不是末尾插入数据的话，要移动数据。</p>
<h1 id="（-ArrayList-扩容）ArrayList-是基于数组的数据结构，但是因为数组是定长的结构，从使用情况来看-ArrayList-并不是，这里怎么解释？"><a href="#（-ArrayList-扩容）ArrayList-是基于数组的数据结构，但是因为数组是定长的结构，从使用情况来看-ArrayList-并不是，这里怎么解释？" class="headerlink" title="（ ArrayList 扩容）ArrayList 是基于数组的数据结构，但是因为数组是定长的结构，从使用情况来看 ArrayList 并不是，这里怎么解释？"></a>（ ArrayList 扩容）ArrayList 是基于数组的数据结构，但是因为数组是定长的结构，从使用情况来看 ArrayList 并不是，这里怎么解释？</h1><p>根据 JDK1.8 的 ArrayList 的算法，可知数据结构内部维护有一个数组。当它达到一定长度后会自动扩容，是因为确定 ArrayList 扩容之后最新的可存储元素个数时，调用<br><code>elementData = Arrays.copyOf(elementData, newCapacity);</code></p>
<h1 id="HashMap-的数据结构是怎样的？"><a href="#HashMap-的数据结构是怎样的？" class="headerlink" title="HashMap 的数据结构是怎样的？"></a>HashMap 的数据结构是怎样的？</h1><p>是一个二维结构，第一维是数组，第二维是链表，jdk1.8 之后，链表在超过阈值后可以转化成红黑树。</p>
<h1 id="HashMap-Get-方法的流程是怎样的？Get-方法的时间复杂度是多少？"><a href="#HashMap-Get-方法的流程是怎样的？Get-方法的时间复杂度是多少？" class="headerlink" title="HashMap Get 方法的流程是怎样的？Get 方法的时间复杂度是多少？"></a>HashMap Get 方法的流程是怎样的？Get 方法的时间复杂度是多少？</h1><p>先调用 key 的 hashcode 方法（key.hashcode()），拿到对象的 hash 值后，用 hash 值对第一维数组的长度进行取模，得到数组下标。其下标所在的元素就是第二维链表的表头。然后遍历链表，用 key.equals() 同链表元素比较，匹配成功就返回链表元素值 Value 。其时间复杂度为 O(1)。</p>
<p>1.判断 key，根据 key 算出索引。<br>2.根据索引获得索引位置所对应的键值对链表。<br>3.遍历键值对链表，根据 key 找到对应的键值对。<br>4.拿到 value 。 </p>
<h1 id="请解释一下-HashMap-的参数-loadFactor-，它的作用是什么？"><a href="#请解释一下-HashMap-的参数-loadFactor-，它的作用是什么？" class="headerlink" title="请解释一下 HashMap 的参数 loadFactor ，它的作用是什么？"></a>请解释一下 HashMap 的参数 loadFactor ，它的作用是什么？</h1><p>用于 HashMap 扩容。<br>loadFactor（负载因子）默认等于 0.75 ，当 HashMap 里面容纳的元素已经达到 HashMap 数组长度的 75% 时，表示 HashMap 太挤了，需要扩容，在 HashMap 的构造器中可以定制 loadFactor 。</p>
<h1 id="为什么-HashMap-是线程不安全的，实际会如何体现？"><a href="#为什么-HashMap-是线程不安全的，实际会如何体现？" class="headerlink" title="为什么 HashMap 是线程不安全的，实际会如何体现？"></a>为什么 HashMap 是线程不安全的，实际会如何体现？</h1><p>假想有很多个线程同时 put() 添加元素，假设正好存在两个 put 的 key 发生了碰撞( hash 值一样)，那么根据 HashMap 的实现，这两个 key 会添加到数组的同一个位置，这样最终就会发生其中一个线程的 put 的数据被覆盖。</p>
<p>此外，如果多个线程同时检测到元素个数超过数组大小*loadFactor ，这样会发生多个线程同时对 hash 数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给 table ，也就是说其他线程的都会丢失，并且各自线程 put 的数据也丢失。最重要的是并发扩容可能会引起死循环的，导致 get 操作时，cpu 100%。</p>
<p>线程安全的HashMap是HashTable、ConcurrentHashMap</p>
<h1 id="Java-中-Runnable-和-Callable-有什么不同？"><a href="#Java-中-Runnable-和-Callable-有什么不同？" class="headerlink" title="Java 中 Runnable 和 Callable 有什么不同？"></a>Java 中 Runnable 和 Callable 有什么不同？</h1><p>在实际开发中一个多线程的操作很少使用 Thread 类，而是通过 Runnable 接口完成。<br>Runnable 和 Callable 功能很相似，不同在于， Callable.call() 可以返回值和抛出异常，而 Runnable.run() 不能。此外 Callable 可以返回装载有计算结果的 Future 对象。Future 表示异步计算的结果。 </p>
<h1 id="在-Java-并发编程中，线程之间如何完成通信？"><a href="#在-Java-并发编程中，线程之间如何完成通信？" class="headerlink" title="在 Java 并发编程中，线程之间如何完成通信？"></a>在 Java 并发编程中，线程之间如何完成通信？</h1><p>共享内存。</p>
<h1 id="Java-中-synchronized-关键字是什么？"><a href="#Java-中-synchronized-关键字是什么？" class="headerlink" title="Java 中 synchronized 关键字是什么？"></a>Java 中 synchronized 关键字是什么？</h1><p>关键字 synchronized 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块。</p>
<h1 id="Java-中的-volatile-变量是什么？"><a href="#Java-中的-volatile-变量是什么？" class="headerlink" title="Java 中的 volatile 变量是什么？"></a>Java 中的 volatile 变量是什么？</h1><p>volatile 是一个特殊的修饰符，只有成员变量才能使用它。本质是告诉 JVM 当前变量在寄存器中的值不确定，需要从主存中获取。而且他不会造成线程的阻塞。在 Java 并发程序缺少同步类的情况下，多线程对成员变量的操作对其它线程是透明的。volatile 变量可以保证下一个读取操作会在前一个写操作之后发生。</p>
<h1 id="Java-中的-volatile-的使用场景与局限性？"><a href="#Java-中的-volatile-的使用场景与局限性？" class="headerlink" title="Java 中的 volatile 的使用场景与局限性？"></a>Java 中的 volatile 的使用场景与局限性？</h1><p>volatile 可以保证内存可见性, 但是不能保证原子性。</p>
<h1 id="什么是-ThreadLocal-变量？"><a href="#什么是-ThreadLocal-变量？" class="headerlink" title="什么是 ThreadLocal 变量？"></a>什么是 ThreadLocal 变量？</h1><p>ThreadLocal 用于线程间的数据隔离，保证在随意修改自己的变量的同时不会影响到其他的线程。它是为创建代价高昂的对象（每次调用都要创建不同的实例）获取线程安全的好方法。</p>
<h1 id="ThreadLocal-和-InheritableThreadLocal-的区别？"><a href="#ThreadLocal-和-InheritableThreadLocal-的区别？" class="headerlink" title="ThreadLocal 和 InheritableThreadLocal 的区别？"></a>ThreadLocal 和 InheritableThreadLocal 的区别？</h1><p>前者不可继承父线程的内容，而后者可以做到很好的在父子线程间传递数据。</p>
<h1 id="多线程中-synchronized-和-Lock-的使用区别？"><a href="#多线程中-synchronized-和-Lock-的使用区别？" class="headerlink" title="多线程中 synchronized 和 Lock 的使用区别？"></a>多线程中 synchronized 和 Lock 的使用区别？</h1><ol>
<li><p>假如线程 A 和 B 都要获取对象 O 的锁定，假设 A 获取了对象 O 锁，B 将等待 A 释放对 O 的锁定。使用 synchronized ，如果 A 一直不释放，B 将一直等待。而使用 Lock ，如果 A 不释放，可以使 B 在等待了足够长的时间以后，中断等待，而干别的事情。</p>
</li>
<li><p>synchronized 是在 JVM 层面上实现的（通过Monitor），不但可以通过一些监控工具监控 synchronized 的锁定，而且在代码执行时出现异常， JVM 会自动释放锁定，但是使用 Lock 则不行，lock 是通过代码实现的，要保证锁定一定会被释放，就必须将 unLock() 放到 finally{} 中。</p>
</li>
<li><p>在资源竞争不是很激烈的情况下， Synchronized 的性能要优于 ReetrantLock ，但是在资源竞争很激烈的情况下， Synchronized 的性能会下降几十倍，但是 ReetrantLock 的性能能维持常态。</p>
</li>
</ol>
<h1 id="JDBC-的-PreparedStatement-是什么？"><a href="#JDBC-的-PreparedStatement-是什么？" class="headerlink" title="JDBC 的 PreparedStatement 是什么？"></a>JDBC 的 PreparedStatement 是什么？</h1><p>是预编译 SQL 语句对象。用它提供的 setter 方法可以传入查询的变量。通过它可以将对应的 SQL 语句高效的执行多次。由于 PreparedStatement 自动对特殊字符转义，避免了 SQL 注入攻击，因此应当尽量的使用它。</p>
<h1 id="Java线程模型定义了哪几种状态？"><a href="#Java线程模型定义了哪几种状态？" class="headerlink" title="Java线程模型定义了哪几种状态？"></a>Java线程模型定义了哪几种状态？</h1><p>在任意一个时间点，一个线程有且只有其中一个状态：</p>
<ol>
<li>新建（New）：新建的 Thread ，尚未开始。</li>
<li>运行（Runable）：包含操作系统线程状态中的 Running、Ready，也就是处于正在执行或正在等待 CPU 分配时间的状态。</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 时间，等待其他线程唤醒。</li>
<li>限期等待（Timed Waiting）：处于这种状态的线程不会被分配 CPU 时间，在一定时间后会由系统自动唤醒。</li>
<li>阻塞（Blocked）：在等待获得排他锁。</li>
<li>结束（Terminated）：已终止的线程。</li>
</ol>
<h1 id="什么是线程安全？"><a href="#什么是线程安全？" class="headerlink" title="什么是线程安全？"></a>什么是线程安全？</h1><p>就是在多个线程同时访问同一段代码的时候，不会产生不确定的结果。</p>
<h1 id="static-关键字有哪些作用？"><a href="#static-关键字有哪些作用？" class="headerlink" title="static 关键字有哪些作用？"></a>static 关键字有哪些作用？</h1><ol>
<li>作用在公共属性上，节省内存。</li>
<li>用作属于类的方法，不会被调用。</li>
<li>用来初始化类的静态数据，在类加载的时候被执行。</li>
</ol>
<h1 id="数据库事务特性？"><a href="#数据库事务特性？" class="headerlink" title="数据库事务特性？"></a>数据库事务特性？</h1><p>ACID，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）的数据库，必须要具有这四种特性。</p>
<h1 id="什么是数据库的隔离级别？"><a href="#什么是数据库的隔离级别？" class="headerlink" title="什么是数据库的隔离级别？"></a>什么是数据库的隔离级别？</h1><p>为了实现数据的一致性使用事务时，数据库系统用锁来防止别人访问事务中用到的数据。<br>隔离级别从高到低有：<br>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</p>
<p>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</p>
<p>Read committed (读已提交)：可避免脏读的发生。</p>
<p>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</p>
<h1 id="什么是数据库索引？"><a href="#什么是数据库索引？" class="headerlink" title="什么是数据库索引？"></a>什么是数据库索引？</h1><p>索引是一种提高数据库查询速度的机制，是对表中列值排序的一种结构。可以加快从表中或视图中检索行的速度，查询时不必进行全表扫描。</p>
<h1 id="Spring-有哪些优点？"><a href="#Spring-有哪些优点？" class="headerlink" title="Spring 有哪些优点？"></a>Spring 有哪些优点？</h1><p>轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。<br>控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。<br>面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。<br>容器：Spring包含并管理应用程序对象的配置及生命周期。<br>MVC框架：Spring的web框架是一个设计优良的web MVC框架，很好的取代了一些web框架。<br>事务管理：Spring对下至本地业务上至全局业务(JAT)提供了统一的事务管理接口。<br>异常处理：Spring提供一个方便的API将特定技术的异常(由JDBC, Hibernate, 或JDO抛出)转化为一致的、Unchecked异常。</p>
<h1 id="Java-中会存在内存泄漏吗？"><a href="#Java-中会存在内存泄漏吗？" class="headerlink" title="Java 中会存在内存泄漏吗？"></a>Java 中会存在内存泄漏吗？</h1><p>虽然有垃圾回收机制，看起来可能不会发生。但是在实际开发中，常常会有一些无用但是可达的对象，这些 GC 不会去回收，因此如果不及时 close 或者 flush ，也有可能发生内存泄漏。</p>
<h1 id="GC-是什么？为什么要有-GC？"><a href="#GC-是什么？为什么要有-GC？" class="headerlink" title="GC 是什么？为什么要有 GC？"></a>GC 是什么？为什么要有 GC？</h1><p>垃圾回收机制，可有效防止内存泄漏，有效的使用可以使用的内存。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/ganru.github.io/tags/学习笔记/" rel="tag"># 学习笔记</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/ganru.github.io/posts/Python笔记/2018-11-24-Web应用（第三部分）.html" rel="next" title="Web应用（第三部分）">
                <i class="fa fa-chevron-left"></i> Web应用（第三部分）
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/ganru.github.io/images/avatar.png"
                alt="Ganru" />
            
              <p class="site-author-name" itemprop="name">Ganru</p>
              <p class="site-description motion-element" itemprop="description">学习一向都是孤独的，慢慢玩。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/ganru.github.io/archives/">
              
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ganru" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ganr1988@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中接口与抽象类的区别？"><span class="nav-number">1.</span> <span class="nav-text">Java 中接口与抽象类的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-对象创建的过程？"><span class="nav-number">2.</span> <span class="nav-text">Java 对象创建的过程？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-重载与重写的区别？"><span class="nav-number">3.</span> <span class="nav-text">Java 重载与重写的区别？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#重载"><span class="nav-number">3.1.</span> <span class="nav-text">重载</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重写"><span class="nav-number">3.2.</span> <span class="nav-text">重写</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#init-方法和-clinit-方法"><span class="nav-number">4.</span> <span class="nav-text">init 方法和 clinit 方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中的引用"><span class="nav-number">5.</span> <span class="nav-text">Java 中的引用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#可达性分析"><span class="nav-number">6.</span> <span class="nav-text">可达性分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-是基本数据类型吗？"><span class="nav-number">7.</span> <span class="nav-text">String 是基本数据类型吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中-Object-类有哪些常用方法？有什么作用？"><span class="nav-number">8.</span> <span class="nav-text">Java 中 Object 类有哪些常用方法？有什么作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#哪个类声明了-clone-方法？是-Cloneable-还是-Object？"><span class="nav-number">9.</span> <span class="nav-text">哪个类声明了 clone 方法？是 Cloneable 还是 Object？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中-操作符是线程安全的吗？"><span class="nav-number">10.</span> <span class="nav-text">Java 中 ++ 操作符是线程安全的吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#基本数据类型和引用类型的区别在哪里？"><span class="nav-number">11.</span> <span class="nav-text">基本数据类型和引用类型的区别在哪里？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#String-类可以继承吗？"><span class="nav-number">12.</span> <span class="nav-text">String 类可以继承吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#final-有什么使用场景？"><span class="nav-number">13.</span> <span class="nav-text">final 有什么使用场景？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中-String，StringBuilder，StringBuffer-的区别"><span class="nav-number">14.</span> <span class="nav-text">Java 中 String，StringBuilder，StringBuffer 的区别</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中-char-是多少个-bit-？-可以存储中文吗？"><span class="nav-number">15.</span> <span class="nav-text">Java 中 char 是多少个 bit ？ 可以存储中文吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#构造器（constructor）是否可被重写（override）？"><span class="nav-number">16.</span> <span class="nav-text">构造器（constructor）是否可被重写（override）？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#成员变量和局部变量的区别"><span class="nav-number">17.</span> <span class="nav-text">成员变量和局部变量的区别?</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#列举-3-4-个集合实现类"><span class="nav-number">18.</span> <span class="nav-text">列举 3-4 个集合实现类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中哪些集合类是线程安全的？哪些集合类是线程不安全的？（各列举至少4个，不许说错）"><span class="nav-number">19.</span> <span class="nav-text">Java 中哪些集合类是线程安全的？哪些集合类是线程不安全的？（各列举至少4个，不许说错）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中-ArrayList-与-LinkedList-实现上的不同-各自试用的场景？"><span class="nav-number">20.</span> <span class="nav-text">Java 中 ArrayList 与 LinkedList 实现上的不同? 各自试用的场景？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#（-ArrayList-扩容）ArrayList-是基于数组的数据结构，但是因为数组是定长的结构，从使用情况来看-ArrayList-并不是，这里怎么解释？"><span class="nav-number">21.</span> <span class="nav-text">（ ArrayList 扩容）ArrayList 是基于数组的数据结构，但是因为数组是定长的结构，从使用情况来看 ArrayList 并不是，这里怎么解释？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-的数据结构是怎样的？"><span class="nav-number">22.</span> <span class="nav-text">HashMap 的数据结构是怎样的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#HashMap-Get-方法的流程是怎样的？Get-方法的时间复杂度是多少？"><span class="nav-number">23.</span> <span class="nav-text">HashMap Get 方法的流程是怎样的？Get 方法的时间复杂度是多少？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#请解释一下-HashMap-的参数-loadFactor-，它的作用是什么？"><span class="nav-number">24.</span> <span class="nav-text">请解释一下 HashMap 的参数 loadFactor ，它的作用是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#为什么-HashMap-是线程不安全的，实际会如何体现？"><span class="nav-number">25.</span> <span class="nav-text">为什么 HashMap 是线程不安全的，实际会如何体现？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中-Runnable-和-Callable-有什么不同？"><span class="nav-number">26.</span> <span class="nav-text">Java 中 Runnable 和 Callable 有什么不同？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#在-Java-并发编程中，线程之间如何完成通信？"><span class="nav-number">27.</span> <span class="nav-text">在 Java 并发编程中，线程之间如何完成通信？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中-synchronized-关键字是什么？"><span class="nav-number">28.</span> <span class="nav-text">Java 中 synchronized 关键字是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中的-volatile-变量是什么？"><span class="nav-number">29.</span> <span class="nav-text">Java 中的 volatile 变量是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中的-volatile-的使用场景与局限性？"><span class="nav-number">30.</span> <span class="nav-text">Java 中的 volatile 的使用场景与局限性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是-ThreadLocal-变量？"><span class="nav-number">31.</span> <span class="nav-text">什么是 ThreadLocal 变量？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#ThreadLocal-和-InheritableThreadLocal-的区别？"><span class="nav-number">32.</span> <span class="nav-text">ThreadLocal 和 InheritableThreadLocal 的区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#多线程中-synchronized-和-Lock-的使用区别？"><span class="nav-number">33.</span> <span class="nav-text">多线程中 synchronized 和 Lock 的使用区别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDBC-的-PreparedStatement-是什么？"><span class="nav-number">34.</span> <span class="nav-text">JDBC 的 PreparedStatement 是什么？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java线程模型定义了哪几种状态？"><span class="nav-number">35.</span> <span class="nav-text">Java线程模型定义了哪几种状态？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是线程安全？"><span class="nav-number">36.</span> <span class="nav-text">什么是线程安全？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#static-关键字有哪些作用？"><span class="nav-number">37.</span> <span class="nav-text">static 关键字有哪些作用？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库事务特性？"><span class="nav-number">38.</span> <span class="nav-text">数据库事务特性？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是数据库的隔离级别？"><span class="nav-number">39.</span> <span class="nav-text">什么是数据库的隔离级别？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#什么是数据库索引？"><span class="nav-number">40.</span> <span class="nav-text">什么是数据库索引？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-有哪些优点？"><span class="nav-number">41.</span> <span class="nav-text">Spring 有哪些优点？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java-中会存在内存泄漏吗？"><span class="nav-number">42.</span> <span class="nav-text">Java 中会存在内存泄漏吗？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#GC-是什么？为什么要有-GC？"><span class="nav-number">43.</span> <span class="nav-text">GC 是什么？为什么要有 GC？</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ganru</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/ganru.github.io/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/ganru.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/ganru.github.io/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/ganru.github.io/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/ganru.github.io/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/ganru.github.io/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/ganru.github.io/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/ganru.github.io/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/ganru.github.io/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
